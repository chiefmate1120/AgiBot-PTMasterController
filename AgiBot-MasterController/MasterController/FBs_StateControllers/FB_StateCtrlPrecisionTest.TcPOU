<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlPrecisionTest" Id="{70f647e6-7c05-4a0c-b17e-4c9a147b0142}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_StateCtrlPrecisionTest EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//arm id
	m_armId:INT;	
	
	//Precision calculation pre matrix
	m_frontPose:ST_Frame;
	
	//Precision calculation post matrix
	m_endPose:ST_Frame;
	
	//single arm pose
	m_masterArmPose:ST_Frame;
	
	//control mode:  1---Joint space single point motion   2---Continuous joint space motion   3---Single point motion in operating space
	//4---Continuous motion in operating space   5---precision test   6---back to origin position   7---maxmum workspace test
	m_controlMode:INT:=1;
	
	//test step
	m_testStep:INT;
	
	//DH joint position
	m_initDHPos,m_startDHPos,m_endDHPos :Vec7d;
	//m_startDHPos:Vec7d;
	
	//startJntPos,endJntPos :Vec8d;
	m_initJntPos,m_startJntPos,m_endJntPos :Vec7d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec7d;
	
	//time
	m_time:LREAL;
	
	//joint motion incresement
	m_jntInc:Vec7d;
	
	//moiton parameters
	m_jntMotionDir:Vec7i:=[0,0,0,0,0,0,0];
	m_jntVel:Vec7d:=[0.1,0.1,0.01,0.2,0.2,0.2,0.2];
	
	//motion start
	m_startMotion:BOOL;
	m_startMotionLast:BOOL;
	
	//target spatial position
	m_targetSpatialPos:ST_Frame;
	
	//spatial motion parameters
	m_spatialMotionDir:Vec6i;
	m_spatialVel:Vec6d;
	
	//spatial position incresement
	m_spatialPosInc:Vec6d;
	
	//initial spatial position
	m_initSpatialPos:ST_Frame;
	
	//target position variables
	m_posInc:Vec3d;
	m_axis:Vec3d;
	m_angle:LREAL;
	
	//accuracy test variables
	m_pointNum:INT;
	m_pointSum:INT;
	m_motionCycleNum:INT;
	
	//Precision testing target position
	m_targetPosArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum] OF ST_Frame;
	m_targetPosVecArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum,1..7] OF LREAL;
	
	//Maximum workspace testing target position
	m_workspacePosArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum] OF ST_Frame;
	m_workspacePosVecArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum,1..7] OF LREAL;
	
	//Has the inverse kinematics been successfully solved
	m_IKSucceed:BOOL;	
	
	//original joint position
	m_originJntPos:Vec7d;
	
	//inverse kinematic idx
	m_IK:INT;
	
	//counter
	m_counter:LREAL;
	
	//motion status
	m_motionFinished:BOOL;
	
	//joint control error and current joint position
	m_actualJntPos,m_JntErr:Vec7d;		
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="accuracyTest" Id="{afebe618-51ed-4fba-83b4-0fb74d6b8114}">
      <Declaration><![CDATA[METHOD accuracyTest : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		activeJnt2DH(i_activeJntPos:= m_endJntPos, o_DHJntPos=> m_endDHPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_actualJntPos:=i_masterArm.curJntPos;
		vecSub(m_cmdJntPos, m_actualJntPos, m_JntErr);
		IF (m_time>m_Planner.duration) AND (norm(m_JntErr)<g_jntCtrlAngTolHigh)THEN
			m_testStep:=15;
		END_IF
				
		
	15: //Waiting for confirmation and measurement
		IF (GVL_AccuracyTestVar.g_nextStep[m_armId]=TRUE) THEN
			GVL_AccuracyTestVar.g_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
	
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
				
				
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_AccuracyTest.g_testMotCycNum) THEN
				m_testStep:=60;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
		
	
	60: //stop
		m_testStep:=-1;	
		m_motionFinished:=TRUE;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="activeJnt2DH" Id="{50536e1b-5ce0-4dc5-b11d-71548f6ebe77}">
      <Declaration><![CDATA[METHOD activeJnt2DH : BOOL
VAR_INPUT
	i_activeJntPos:Vec7d;
END_VAR

VAR_OUTPUT
	o_DHJntPos:Vec7d;
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
o_DHJntPos:=i_activeJntPos;
o_DHJntPos[3]:=i_activeJntPos[3]-i_activeJntPos[2]; //q8 = q3+q2-----q3=q8-q2
o_DHJntPos[4]:=i_activeJntPos[4]+i_activeJntPos[3]-i_activeJntPos[2]-pi/2; //q4DH=q4motor+q8-q2-90; ----q4motor=q4DH+q2-q8+90
]]></ST>
      </Implementation>
    </Method>
    <Method Name="armFK" Id="{eb34cec9-c1b5-4340-b7a7-1a5b5e58eab3}">
      <Declaration><![CDATA[// from active joint position to cartesian pose in arm origin
//METHOD PROTECTED forwardKinematic : BOOL
METHOD PUBLIC armFK : BOOL
VAR_IN_OUT CONSTANT
	i_jntPos :ARRAY[1..g_mJntNum] OF LREAL;
	i_gripperRollFlip:BOOL;
END_VAR
VAR_IN_OUT
	r_cartPose :ST_Frame;
END_VAR
VAR
	q1,q2, q3, q4, q5, q6, q7 :LREAL;
	d1,d4,a3,a4 :LREAL;
	c1,c2,c3,c4,c5,c6,c7 :LREAL;
	s1,s2,s3,s4,s5,s6,s7 :LREAL;
	c23, s23 :LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// !Convert active joint position to DH model for kinematic calculation
q1:=i_jntPos[1];  
q2:=i_jntPos[2];  
q3:=i_jntPos[3]-i_jntPos[2];  //q3=q8-q2
q4:=jnt4MotorToLink(i_jntPos[2],i_jntPos[3], i_jntPos[4]);//q4DH=q4motor+q8-q2-90;  
q5:=i_jntPos[5];
q6:=i_jntPos[6];
q7:=i_jntPos[7];

// master roll flip handle
IF (i_gripperRollFlip=TRUE) THEN
	q7 := q7+PI;
END_IF

d1:=g_d1;
d4:=g_d4;
a3:=g_a3;
a4:=g_a4;
c1:=COS(q1);
c2:=COS(q2);
c3:=COS(q3);
c4:=COS(q4);
c5:=COS(q5);
c6:=COS(q6);
c7:=COS(q7);
s1:=SIN(q1);
s2:=SIN(q2);
s3:=SIN(q3);
s4:=SIN(q4);
s5:=SIN(q5);
s6:=SIN(q6);
s7:=SIN(q7);
c23:=COS(q2+q3);
s23:=SIN(q2+q3);

// cartesian pose frame
r_cartPose.m_pos[1]:=c1*(a4*c23 - d4*s23 + a3*c2); 
r_cartPose.m_pos[2]:=s1*(a4*c23 - d4*s23 + a3*c2);
r_cartPose.m_pos[3]:=d1 - d4*c23 - a4*s23 - a3*s2;  
r_cartPose.m_rot[1,1]:=c7*(s6*(c4*s1 - s4*(c1*c2*c3 - c1*s2*s3)) + c6*(c5*(s1*s4 + c4*(c1*c2*c3 - c1*s2*s3)) - s5*(c1*c2*s3 + c1*c3*s2))) - s7*(s5*(s1*s4 + c4*(c1*c2*c3 - c1*s2*s3)) + c5*(c1*c2*s3 + c1*c3*s2));
r_cartPose.m_rot[2,1]:=s7*(s5*(c1*s4 + c4*(s1*s2*s3 - c2*c3*s1)) - c5*(c2*s1*s3 + c3*s1*s2)) - c7*(s6*(c1*c4 - s4*(s1*s2*s3 - c2*c3*s1)) + c6*(c5*(c1*s4 + c4*(s1*s2*s3 - c2*c3*s1)) + s5*(c2*s1*s3 + c3*s1*s2)));
r_cartPose.m_rot[3,1]:=- s7*(c23*c5 - s23*c4*s5) - c7*(c23*c6*s5 - s23*s4*s6 + s23*c4*c5*c6); 
r_cartPose.m_rot[1,2]:=- s7*(s6*(c4*s1 - s4*(c1*c2*c3 - c1*s2*s3)) + c6*(c5*(s1*s4 + c4*(c1*c2*c3 - c1*s2*s3)) - s5*(c1*c2*s3 + c1*c3*s2))) - c7*(s5*(s1*s4 + c4*(c1*c2*c3 - c1*s2*s3)) + c5*(c1*c2*s3 + c1*c3*s2)); 
r_cartPose.m_rot[2,2]:=s7*(s6*(c1*c4 - s4*(s1*s2*s3 - c2*c3*s1)) + c6*(c5*(c1*s4 + c4*(s1*s2*s3 - c2*c3*s1)) + s5*(c2*s1*s3 + c3*s1*s2))) + c7*(s5*(c1*s4 + c4*(s1*s2*s3 - c2*c3*s1)) - c5*(c2*s1*s3 + c3*s1*s2)); 
r_cartPose.m_rot[3,2]:=s7*(c23*c6*s5 - s23*s4*s6 + s23*c4*c5*c6) - c7*(c23*c5 - s23*c4*s5); 
r_cartPose.m_rot[1,3]:=s6*(c5*(s1*s4 + c4*(c1*c2*c3 - c1*s2*s3)) - s5*(c1*c2*s3 + c1*c3*s2)) - c6*(c4*s1 - s4*(c1*c2*c3 - c1*s2*s3)); 
r_cartPose.m_rot[2,3]:=c6*(c1*c4 - s4*(s1*s2*s3 - c2*c3*s1)) - s6*(c5*(c1*s4 + c4*(s1*s2*s3 - c2*c3*s1)) + s5*(c2*s1*s3 + c3*s1*s2));
r_cartPose.m_rot[3,3]:=- s6*(c23*s5 + s23*c4*c5) - s23*c6*s4;]]></ST>
      </Implementation>
    </Method>
    <Method Name="armIK" Id="{fa1d2218-d930-4856-88fa-79a4d5db2b2e}">
      <Declaration><![CDATA[// from cartesian pose in arm origin to active joint position
//METHOD PROTECTED inverseKinematic : BOOL
METHOD armIK : BOOL
VAR_INPUT
	q4:LREAL; //q4DH
	solution_ID:INT; //solution ID
END_VAR
VAR_IN_OUT CONSTANT
	i_curCartPose :ST_Frame;
END_VAR
VAR_IN_OUT
	r_jntPos :ARRAY[1..g_mJntNum] OF LREAL;
END_VAR
VAR
	a3,a4,d1,d4:LREAL;
	px,py,pz:lreal;
	nx,ny,nz:lreal;
	ox,oy,oz:lreal;
	ax,ay,az:lreal;

	q1,q2,q3,q5,q6,q7:LREAL;
	
	q11,q12:LREAL;
	k1,A,B,C,fi,R0,q21,q22:lreal;
	ins1,ins2:lreal;
	
	A11,A12,A21,A22,C1,C2:lreal;
	SIN23,COS23,q23:LREAL;
	
	T_74_left_23,q61,q62:lreal;
	T_74_left_13,T_74_left_33:lreal;
	T_74_left_21,T_74_left_22:LREAL;	
	succeed_1,succeed_2,succeed:BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

//***********************单臂逆向运动学**************************//
d1:=g_d1;
d4:=g_d4;
a3:=g_a3;
a4:=g_a4;

nx:=i_curCartPose.m_rot[1,1];  ny:=i_curCartPose.m_rot[2,1];  nz:=i_curCartPose.m_rot[3,1];
ox:=i_curCartPose.m_rot[1,2]; oy:=i_curCartPose.m_rot[2,2];  oz:=i_curCartPose.m_rot[3,2];
ax:=i_curCartPose.m_rot[1,3];  ay:=i_curCartPose.m_rot[2,3];  az:=i_curCartPose.m_rot[3,3];
px:=i_curCartPose.m_pos[1]; py:=i_curCartPose.m_pos[2]; pz:=i_curCartPose.m_pos[3];


//求解q1
q11:=atan2(y:= py, x:= px);
q12:=atan2(y:= -py, x:= -px);
IF (Solution_ID<=4) THEN
	q1:=q11;
ELSE
	q1:=q12;
END_IF



//求解q2
k1:=px*COS(q1) + py*SIN(q1);
A:=2*a3*pz - 2*a3*d1;
B:=2*a3*k1;
C:=a3*a3 - a4*a4 + d1*d1 - 2*d1*pz - d4*d4 + k1*k1 + pz*pz;
fi:=atan2(y:= B, x:= A);
R0:=SQRT(A*A+B*B);


//*************程序保护性处理，避免软件崩溃***************//
IF ABS(C/R0)>1 THEN
	succeed_1:=FALSE;
	succeed:=FALSE;
	armIK:=FALSE;
	RETURN;
ELSE
	succeed_1:=TRUE;
END_IF

ins1:=atan2(y:= C/R0, x:= SQRT(1-(C/R0)*(C/R0)));
q21:=fi-ins1;
ins2:=atan2(y:= C/R0, x:= -SQRT(1-(C/R0)*(C/R0)));
q22:=fi-ins2;

IF (Solution_ID=1) OR (Solution_ID=2) OR (Solution_ID=5) OR (Solution_ID=6) THEN
	q2:=q21;
ELSE
	q2:=q22;
END_IF




//求解q3
A11:=- d4;
A12:=a4;
A21:=- a4;
A22:=-d4;
C1:=k1- a3*COS(q2);
C2:=pz - d1 + a3*SIN(q2);
sin23:=(C1*A22-C2*A12)/(A11*A22-A21*A12);
cos23:=(C2*A11-C1*A21)/(A11*A22-A21*A12);
q23:=atan2(y:= sin23, x:= cos23);
q3:=q23-q2;




//求解q6
T_74_left_23:=ax*(COS(q4)*SIN(q1) - COS(q1)*COS(q2)*COS(q3)*SIN(q4) + COS(q1)*SIN(q2)*SIN(q3)*SIN(q4)) - ay*(COS(q1)*COS(q4) + COS(q2)*COS(q3)*SIN(q1)*SIN(q4) - SIN(q1)*SIN(q2)*SIN(q3)*SIN(q4)) + az*SIN(q2 + q3)*SIN(q4);

//*************程序保护性处理，避免软件崩溃***************//
IF ABS(T_74_left_23>1) THEN
	succeed_2:=FALSE;
	succeed:=FALSE;
	armIK:=FALSE;
	RETURN;
ELSE
	succeed_2:=TRUE;
END_IF

q61:=ACOS(-T_74_left_23);
q62:=-ACOS(-T_74_left_23);
IF (Solution_ID=1) OR (Solution_ID=3) OR (Solution_ID=5) OR (Solution_ID=7) THEN
	q6:=q61;
ELSE
	q6:=q62;
END_IF



//求解q5
T_74_left_13:=ax*(SIN(q1)*SIN(q4) + COS(q1)*COS(q2)*COS(q3)*COS(q4) - COS(q1)*COS(q4)*SIN(q2)*SIN(q3)) - ay*(COS(q1)*SIN(q4) - COS(q2)*COS(q3)*COS(q4)*SIN(q1) + COS(q4)*SIN(q1)*SIN(q2)*SIN(q3)) - az*SIN(q2 + q3)*COS(q4);
T_74_left_33:=- az*COS(q2 + q3) - ax*SIN(q2 + q3)*COS(q1) - ay*SIN(q2 + q3)*SIN(q1);
q5:=atan2(y:= T_74_left_33*SIN(q6), x:= T_74_left_13*SIN(q6));



//求解q7
T_74_left_21:=nx*(COS(q4)*SIN(q1) - COS(q1)*COS(q2)*COS(q3)*SIN(q4) + COS(q1)*SIN(q2)*SIN(q3)*SIN(q4)) - ny*(COS(q1)*COS(q4) + COS(q2)*COS(q3)*SIN(q1)*SIN(q4) - SIN(q1)*SIN(q2)*SIN(q3)*SIN(q4)) + nz*SIN(q2 + q3)*SIN(q4);
T_74_left_22:=ox*(COS(q4)*SIN(q1) - COS(q1)*COS(q2)*COS(q3)*SIN(q4) + COS(q1)*SIN(q2)*SIN(q3)*SIN(q4)) - oy*(COS(q1)*COS(q4) + COS(q2)*COS(q3)*SIN(q1)*SIN(q4) - SIN(q1)*SIN(q2)*SIN(q3)*SIN(q4)) + oz*SIN(q2 + q3)*SIN(q4);
q7:=atan2(y:= -T_74_left_22*SIN(q6), x:= T_74_left_21*SIN(q6));



//output DH joint position
r_jntPos[1]:=q1;
r_jntPos[2]:=q2;
r_jntPos[3]:=q3;
r_jntPos[4]:=q4;
r_jntPos[5]:=q5;
r_jntPos[6]:=q6;
r_jntPos[7]:=q7;

succeed:=TRUE;
armIK:=succeed;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="armIKSlove" Id="{77e37168-bd57-4505-973d-e5e6112185cf}">
      <Declaration><![CDATA[METHOD armIKSlove : BOOL
VAR_INPUT	
	i_masterArm :FB_MasterArm;
	i_q4:LREAL;
	i_targetFrame:ST_Frame;
END_VAR

VAR_OUTPUT
	o_targetJntPos:Vec7d;
END_VAR

VAR
	i:INT;
	IKSucceed:BOOL;
	targetJntPos:Vec7d;		
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Call inverse kinematics
IKSucceed:=armIK(q4:= i_q4, solution_ID:= m_IK, i_curCartPose:= i_targetFrame, r_jntPos:= targetJntPos);
IF (IKSucceed=FALSE) THEN
	armIKSlove:=FALSE;
	RETURN;
END_IF


//Constrained solution range and transform to active joint position
FOR i:=1 TO 7 BY 1 DO
	minimumDistMot(i_current:= GVL_AccuracyTest.g_jntDHInitPos[m_armId,i], i_target:= targetJntPos[i], o_target=> targetJntPos[i]);
END_FOR
DH2activeJnt(i_DHJntPos:= targetJntPos, o_activeJntPos=> o_targetJntPos);


//Determine whether the solution result is appropriate
FOR i:=1 TO g_mJntNum BY 1 DO
	IF (o_targetJntPos[i]>GVL_ArmJointParameters.g_maxJntPos[m_armId,i]) OR (o_targetJntPos[i]<GVL_ArmJointParameters.g_minJntPos[m_armId,i]) THEN
		armIKSlove:=FALSE;
		RETURN;
	END_IF
END_FOR
armIKSlove:=TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="back2origin" Id="{65a779a8-38b1-4897-9383-89c538a91bfc}">
      <Declaration><![CDATA[METHOD back2origin : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;		
		m_motionFinished:=TRUE;
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{0fa515f5-8ed2-411f-8a91-980e3960824a}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR
	i:INT;
	tmpFrame:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Basic information update---front pose frame and end pose frame
m_frontPose:=i_shoulderPose;
m_endPose.m_pos:=g_zeroVec3d;  m_endPose.m_rot:=g_eye3d;
m_masterArmPose:=i_masterArm.curCartPose;


//copy to global variables
GVL_AccuracyTestVar.g_frontPose[m_armId]:=m_frontPose;
GVL_AccuracyTestVar.g_endPose[m_armId]:=m_endPose;
GVL_AccuracyTestVar.g_masterArmPose[m_armId]:=m_masterArmPose;


//Initialization of motion parameters
m_startMotion:=GVL_AccuracyTestVar.g_startMotion[m_armId];
IF (m_startMotionLast=FALSE) AND (m_startMotion=TRUE) THEN
	motionParamInit(i_masterArm);
END_IF
m_startMotionLast:=m_startMotion;


//Select different programs based on different control modes
IF (m_startMotion=TRUE) THEN
	IF (m_controlMode=1) THEN
		//jntSinglePoint(i_masterArm);	
		
	ELSIF (m_controlMode=2) THEN
		jntContinuousPoint(i_masterArm);	
		
	ELSIF (m_controlMode=3) THEN
		//spaceSinglePoint(i_masterArm);	
		
	ELSIF (m_controlMode=4) THEN
		spaceContinuousPoint(i_masterArm);
		
	ELSIF (m_controlMode=5) THEN
		accuracyTest(i_masterArm);
		
	ELSIF (m_controlMode=6) THEN
		back2origin(i_masterArm);
		
	ELSIF (m_controlMode=7) THEN
		maxSpaceTest(i_masterArm);
	END_IF
END_IF


//show the motion step
IF (m_controlMode=5) OR (m_controlMode=7) THEN
	GVL_AccuracyTestVar.g_curStep[m_armId]:=m_testStep;
	GVL_AccuracyTestVar.g_testPointId[m_armId]:=m_pointNum;
	GVL_AccuracyTestVar.g_testCycleId[m_armId]:=m_motionCycleNum;
ELSE
	GVL_AccuracyTestVar.g_curStep[m_armId]:=-1;
	GVL_AccuracyTestVar.g_testPointId[m_armId]:=0;
	GVL_AccuracyTestVar.g_testCycleId[m_armId]:=0;
END_IF



// feedback the motion status
IF (m_controlMode=1) OR (m_controlMode=3) OR (m_controlMode=5) OR (m_controlMode=6) OR (m_controlMode=7) THEN
	IF (m_testStep=-1) AND (m_motionFinished=TRUE) THEN
		m_controlMode:=0;
		GVL_AccuracyTestVar.g_controlMode[m_armId]:=0;	
	END_IF
ELSIF (m_controlMode=2) OR (m_controlMode=4) THEN
	IF (m_startMotion=FALSE) THEN
		m_controlMode:=0;
		GVL_AccuracyTestVar.g_controlMode[m_armId]:=0;
	END_IF
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="DH2activeJnt" Id="{58552599-1e5c-4b5a-adea-35c811ab0e69}">
      <Declaration><![CDATA[METHOD DH2activeJnt : BOOL
VAR_INPUT
	i_DHJntPos:Vec7d;
END_VAR
VAR_OUTPUT
	o_activeJntPos:Vec7d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
o_activeJntPos:=i_DHJntPos;
o_activeJntPos[3]:=i_DHJntPos[3]+i_DHJntPos[2]; //  q8 = q3+q2
o_activeJntPos[4]:=i_DHJntPos[4]+i_DHJntPos[2]-o_activeJntPos[3]+pi/2; //q4DH=q4motor+q8-q2-90; ----q4motor=q4DH+q2-q8+90
]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{9671ba1f-3786-4353-99b0-532f4e991b3d}">
      <Declaration><![CDATA[// override this function in each exact controller
// NOTICE: set joint control mode here, and do some initialization if needed
METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

//variable initialization
m_armId:=i_masterArm.armIdx;

//init IK idx
IF (m_armId=1) THEN
	m_IK:=4;
ELSE
	m_IK:=3;
END_IF

//motion parameters initial
motionParamInit(i_masterArm);]]></ST>
      </Implementation>
    </Method>
    <Method Name="jnt4MotorToLink" Id="{03eebf10-39ef-4fb2-951f-cd0c78680d11}">
      <Declaration><![CDATA[//convert joint4 position from motor side to link side
METHOD public jnt4MotorToLink : LREAL
VAR_INPUT
	i_q2 :LREAL;
	i_q3:LREAL;
	i_q4Motor :LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[jnt4MotorToLink:=i_q4Motor+i_q3-i_q2-pi/2;//q4DH=q4motor+q8-q2-90;  ]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntContinuousPoint" Id="{c90c65c0-8df3-44f1-bc0e-2550eda41a32}">
      <Declaration><![CDATA[METHOD jntContinuousPoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//joint motion incresement calculation
FOR i:=1 TO g_mJntNum BY 1 DO
	m_jntInc[i]:=m_jntInc[i]+m_jntMotionDir[i]*m_jntVel[i]*g_armCtrlCycleTime;
END_FOR

//determine DH joint position
vecAdd(m_initDHPos,m_jntInc,m_endDHPos);
DH2activeJnt(i_DHJntPos:= m_endDHPos, o_activeJntPos=> m_endJntPos);
m_cmdJntPos:=m_endJntPos;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntSinglePoint" Id="{b52fbfef-81d7-4e11-ba89-b951ebd949dd}">
      <Declaration><![CDATA[METHOD jntSinglePoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=GVL_AccuracyTestVar.g_targetJntPos[m_armId];		
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="maxSpaceTest" Id="{b743c633-b946-4183-8086-7c964c58d1ae}">
      <Declaration><![CDATA[METHOD maxSpaceTest : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //data initial
		m_targetSpatialPos:=m_workspacePosArr[m_pointNum];
		activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF
		
		
	10: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_actualJntPos:=i_masterArm.curJntPos;
		vecSub(m_cmdJntPos, m_actualJntPos, m_JntErr);
		IF (m_time>m_Planner.duration) AND (norm(m_JntErr)<g_jntCtrlAngTolHigh)THEN
			m_testStep:=15;
		END_IF
		
		
	15: //Waiting for confirmation and measurement
		IF (GVL_AccuracyTestVar.g_nextStep[m_armId]=TRUE) THEN
			GVL_AccuracyTestVar.g_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
		
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
		
		
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_AccuracyTest.g_testMotCycNum) THEN
				m_testStep:=60;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
				
			
	60: //stop
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="minimumDistMot" Id="{5a0f1a70-9b08-4cd3-8346-069ed64a6a23}">
      <Declaration><![CDATA[METHOD minimumDistMot : BOOL
VAR_INPUT
	i_current:LREAL;
	i_target:LREAL;
END_VAR
VAR_OUTPUT
	o_target:LREAL;
END_VAR
VAR
	p1,p2,p3,p4:LREAL;
	d1,d2,d3:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
p1:=i_current;

p2:=i_target;            d1:=ABS(p2-p1);
p3:=i_target+2*pi;      d2:=ABS(p3-p1);
p4:=i_target-2*pi;       d3:=ABS(p4-p1);

IF (d1<d2 AND d1<d3) THEN
	o_target:=p2;
ELSIF (d2<d1 AND d2<d3) THEN
	o_target:=p3;
ELSE
	o_target:=p4;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="motionParamInit" Id="{307213d8-b11a-481a-bd29-12db6287c686}">
      <Declaration><![CDATA[METHOD motionParamInit : BOOL
VAR_INPUT
	// arm data
	i_masterArm:FB_MasterArm;
END_VAR
VAR
	i,j:INT;
	poseVec:Vec6d;
	originPose:ST_Frame;
	gripperRollFlip:BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_testStep:=0;
m_time:=0;
m_controlMode:=GVL_AccuracyTestVar.g_controlMode[m_armId];
m_counter:=0;
m_motionFinished:=FALSE;


//joint continuous motion parameters
activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_initDHPos);
m_jntInc:=g_zeroVec7d;
m_jntMotionDir:=GVL_AccuracyTestVar.g_jntMotionDir[m_armId];
m_jntVel:=GVL_AccuracyTestVar.g_jntVel[m_armId];
FOR i:=1 TO 7 BY 1 DO
	m_jntVel[i]:=LIMIT(-0.1,m_jntVel[i],0.1);
END_FOR


//spatial continuous motion parameters
m_spatialMotionDir:=GVL_AccuracyTestVar.g_spatialMotionDir[m_armId];
m_spatialVel:=GVL_AccuracyTestVar.g_spatialVel[m_armId];
m_initSpatialPos:=i_masterArm.curCartPose;
m_spatialPosInc:=g_zeroVec6d;
FOR i:=1 TO 3 BY 1 DO
	m_spatialVel[i]:=LIMIT(-0.01,m_spatialVel[i],0.01);
END_FOR
FOR i:=4 TO 6 BY 1 DO
	m_spatialVel[i]:=LIMIT(-0.1,m_spatialVel[i],0.1);
END_FOR


//velocity---acceleration---jerk-----------//-----modify1118
vecMultiNum(GVL_ArmJointParameters.g_maxJntVel,0.2,m_maxjntVel);
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);


//accuracy test variables
m_pointNum:=1;
m_pointSum:=8;
m_motionCycleNum:=1;


//original joint position
FOR i:=1 TO g_mJntNum BY 1 DO
	m_originJntPos[i]:=GVL_ArmJointCaliData.g_linkEncCaliJntPos[m_armId,i];
END_FOR


//test point record
IF (m_armId=1) THEN
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA1;
	m_workspacePosVecArr:=GVL_AccuracyTest.g_maxSpaceArm1;
ELSE
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA2;
	m_workspacePosVecArr:=GVL_AccuracyTest.g_maxSpaceArm2;
END_IF


//Accuracy testing target position
FOR i:=1 TO GVL_AccuracyTest.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_targetPosVecArr[i,j];
	END_FOR
	xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_targetPosArr[i]);
	gripperRollFlip:= i_masterArm.gripperRollFlip;
	armFK(i_jntPos:= m_originJntPos, i_gripperRollFlip:=gripperRollFlip, r_cartPose:= originPose);
	m_targetPosArr[i].m_rot:=originPose.m_rot;
END_FOR


//Maximum workspace testing target position
FOR i:=1 TO GVL_AccuracyTest.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_workspacePosVecArr[i,j];
	END_FOR
	xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_workspacePosArr[i]);
	armFK(i_jntPos:= m_originJntPos, i_gripperRollFlip:=gripperRollFlip, r_cartPose:= originPose);
	m_workspacePosArr[i].m_rot:=originPose.m_rot;
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="rpy2rot" Id="{2a77c0e7-fd72-47f1-a5e9-51bdfe702e1b}">
      <Declaration><![CDATA[METHOD rpy2rot : BOOL
VAR_INPUT
	i_rpy:Vec3d;
END_VAR

VAR_OUTPUT
	o_rot:Mat3d;
END_VAR

VAR
	rot_x,rot_y,rot_z:LREAL;
	alpha,beta,gama:LREAL;
	matrix_out:ARRAY[1..3,1..3] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
alpha:=rot_z;
beta:=rot_y;
gama:=rot_x;

matrix_out[1,1]:=COS(alpha)*COS(beta);
matrix_out[2,1]:=SIN(alpha)*COS(beta);
matrix_out[3,1]:=-SIN(beta);

matrix_out[1,2]:=COS(alpha)*SIN(beta)*SIN(gama)-SIN(alpha)*COS(gama);
matrix_out[2,2]:=SIN(alpha)*SIN(beta)*SIN(gama)+COS(alpha)*COS(gama);
matrix_out[3,2]:=COS(beta)*SIN(gama);

matrix_out[1,3]:=COS(alpha)*SIN(beta)*COS(gama)+SIN(alpha)*SIN(gama);
matrix_out[2,3]:=SIN(alpha)*SIN(beta)*COS(gama)-COS(alpha)*SIN(gama);
matrix_out[3,3]:=COS(beta)*COS(gama);

o_rot:=matrix_out;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceContinuousPoint" Id="{6d82d01c-ca27-4e66-8af1-0fba9fec3714}">
      <Declaration><![CDATA[METHOD spaceContinuousPoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	i:INT;
	rotMatrix:Mat3d;
	tmpFrame:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

//spatial motion incresement calculation
FOR i:=1 TO 6 BY 1 DO
	m_spatialPosInc[i]:=m_spatialPosInc[i]+m_spatialMotionDir[i]*m_spatialVel[i]*g_armCtrlCycleTime;
END_FOR


//Calculate the target pose matrix
FOR i:=1 TO 3 BY 1 DO
	m_posInc[i]:=m_spatialPosInc[i];
	m_axis[i]:=m_spatialMotionDir[i+3]; //modify1118
END_FOR
m_angle:=norm(m_spatialPosInc);
tmpFrame.m_pos:=m_posInc;
tmpFrame.m_rot:=angAxis2Rot(m_angle,m_axis);
m_targetSpatialPos:=transform(m_initSpatialPos,tmpFrame);


//Inverse kinematics solution of surgical arm
activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);
m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
IF (m_IKSucceed=FALSE) THEN
	RETURN;
END_IF
m_cmdJntPos:=m_endJntPos;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceSinglePoint" Id="{6f6e85b5-3e0b-492e-b9bb-00296dfc14b0}">
      <Declaration><![CDATA[METHOD spaceSinglePoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_targetSpatialPos:=GVL_AccuracyTestVar.g_targetSpatialPos[m_armId];
		activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=20;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="xyzrpy2Frame" Id="{386a3d45-d2c1-4c32-a59e-a596651a6100}">
      <Declaration><![CDATA[METHOD xyzrpy2Frame : BOOL
VAR_INPUT
	i_posVec:Vec6d;
END_VAR

VAR_OUTPUT
	o_frame:ST_Frame;
END_VAR

VAR
	i:INT;
	rpyVec:Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:=1 TO 3 BY 1 DO
	o_frame.m_pos[i]:=i_posVec[i];
	rpyVec[i]:=i_posVec[i+3];
END_FOR
rpy2rot(i_rpy:= rpyVec, o_rot=> o_frame.m_rot) ;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlPrecisionTest">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.accuracyTest">
      <LineId Id="7" Count="0" />
      <LineId Id="13" Count="3" />
      <LineId Id="61" Count="1" />
      <LineId Id="119" Count="0" />
      <LineId Id="19" Count="4" />
      <LineId Id="25" Count="10" />
      <LineId Id="114" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="36" Count="2" />
      <LineId Id="112" Count="0" />
      <LineId Id="63" Count="1" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="81" Count="15" />
      <LineId Id="77" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="41" Count="9" />
      <LineId Id="101" Count="1" />
      <LineId Id="51" Count="4" />
      <LineId Id="107" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.activeJnt2DH">
      <LineId Id="23" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.armFK">
      <LineId Id="84" Count="3" />
      <LineId Id="163" Count="0" />
      <LineId Id="89" Count="2" />
      <LineId Id="180" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="181" Count="3" />
      <LineId Id="92" Count="24" />
      <LineId Id="140" Count="7" />
      <LineId Id="29" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.armIK">
      <LineId Id="13" Count="2" />
      <LineId Id="131" Count="2" />
      <LineId Id="19" Count="5" />
      <LineId Id="27" Count="18" />
      <LineId Id="47" Count="0" />
      <LineId Id="238" Count="0" />
      <LineId Id="48" Count="4" />
      <LineId Id="239" Count="0" />
      <LineId Id="53" Count="40" />
      <LineId Id="240" Count="0" />
      <LineId Id="94" Count="11" />
      <LineId Id="199" Count="0" />
      <LineId Id="106" Count="5" />
      <LineId Id="200" Count="0" />
      <LineId Id="112" Count="6" />
      <LineId Id="202" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="119" Count="11" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.armIKSlove">
      <LineId Id="26" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.back2origin">
      <LineId Id="7" Count="4" />
      <LineId Id="14" Count="17" />
      <LineId Id="39" Count="0" />
      <LineId Id="32" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.calcCmdJntPos">
      <LineId Id="12" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="32" Count="3" />
      <LineId Id="22" Count="3" />
      <LineId Id="13" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="39" Count="4" />
      <LineId Id="37" Count="1" />
      <LineId Id="44" Count="19" />
      <LineId Id="79" Count="2" />
      <LineId Id="64" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="83" Count="2" />
      <LineId Id="88" Count="1" />
      <LineId Id="107" Count="1" />
      <LineId Id="91" Count="1" />
      <LineId Id="109" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="155" Count="0" />
      <LineId Id="158" Count="0" />
      <LineId Id="161" Count="0" />
      <LineId Id="159" Count="1" />
      <LineId Id="165" Count="1" />
      <LineId Id="169" Count="1" />
      <LineId Id="168" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="163" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.DH2activeJnt">
      <LineId Id="26" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.init">
      <LineId Id="12" Count="4" />
      <LineId Id="25" Count="0" />
      <LineId Id="19" Count="2" />
      <LineId Id="23" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.jnt4MotorToLink">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.jntContinuousPoint">
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="6" />
      <LineId Id="25" Count="0" />
      <LineId Id="8" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.jntSinglePoint">
      <LineId Id="7" Count="1" />
      <LineId Id="19" Count="2" />
      <LineId Id="24" Count="4" />
      <LineId Id="12" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="29" Count="8" />
      <LineId Id="16" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.maxSpaceTest">
      <LineId Id="8" Count="0" />
      <LineId Id="15" Count="2" />
      <LineId Id="57" Count="1" />
      <LineId Id="20" Count="15" />
      <LineId Id="142" Count="3" />
      <LineId Id="38" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="63" Count="3" />
      <LineId Id="62" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="99" Count="15" />
      <LineId Id="95" Count="1" />
      <LineId Id="98" Count="0" />
      <LineId Id="41" Count="9" />
      <LineId Id="125" Count="1" />
      <LineId Id="51" Count="1" />
      <LineId Id="123" Count="0" />
      <LineId Id="54" Count="1" />
      <LineId Id="134" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.minimumDistMot">
      <LineId Id="6" Count="0" />
      <LineId Id="17" Count="13" />
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.motionParamInit">
      <LineId Id="10" Count="2" />
      <LineId Id="122" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="155" Count="0" />
      <LineId Id="16" Count="2" />
      <LineId Id="134" Count="0" />
      <LineId Id="136" Count="1" />
      <LineId Id="105" Count="0" />
      <LineId Id="19" Count="5" />
      <LineId Id="140" Count="1" />
      <LineId Id="138" Count="0" />
      <LineId Id="143" Count="1" />
      <LineId Id="142" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="25" Count="4" />
      <LineId Id="107" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="108" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="73" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="92" Count="0" />
      <LineId Id="77" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="36" Count="6" />
      <LineId Id="170" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="45" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="97" Count="4" />
      <LineId Id="168" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="94" Count="2" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.rpy2rot">
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="7" />
      <LineId Id="30" Count="2" />
      <LineId Id="34" Count="3" />
      <LineId Id="39" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.spaceContinuousPoint">
      <LineId Id="7" Count="0" />
      <LineId Id="12" Count="4" />
      <LineId Id="46" Count="0" />
      <LineId Id="18" Count="9" />
      <LineId Id="47" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="58" Count="1" />
      <LineId Id="32" Count="2" />
      <LineId Id="38" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.spaceSinglePoint">
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="4" />
      <LineId Id="49" Count="0" />
      <LineId Id="16" Count="4" />
      <LineId Id="22" Count="17" />
      <LineId Id="54" Count="0" />
      <LineId Id="40" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlPrecisionTest.xyzrpy2Frame">
      <LineId Id="7" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>