<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlMasterSlave" Id="{5b96f309-da76-444d-a9fb-2d4321895cd7}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Master Arm MasterSlave controller
FUNCTION_BLOCK PUBLIC FB_StateCtrlMasterSlave EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// joint4 controller
	m_redunJntCtrl : FB_RedunJntControl;
	
	// flag if project joint4 torque to nullspace
	m_nullspaceCtrl : BOOL :=FALSE;
	
	// boundary limit force feedback
	m_boundaryForce : FB_boundaryForceFeedback;
	
	// joint6 software limit control
	m_jnt6LimitCtrl :FB_Jnt6SWLimit;
	
	// joint torque for master-slave error
	m_boundaryTrq :Vec7d;
	
	// friction compensation scale
	m_frictionCompScale :LREAL :=1.0;

	
	
	//*****************Variables related to accuracy testing*******************//
	//test step
	m_testStep:INT;
	
	//target spatial position
	m_targetSpatialPos:ST_Frame;
	
	//Precision testing target position
	m_targetPosArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum] OF ST_Frame;
	m_targetPosVecArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum,1..7] OF LREAL;
	
	//accuracy test variables
	m_pointNum:INT;
	m_pointSum:INT;
	m_motionCycleNum:INT;
	
	//DH joint position
	//m_initDHPos,m_startDHPos,m_endDHPos :Vec7d;
	m_startDHPos:Vec7d;
	
	//startJntPos,endJntPos :Vec8d;
	m_initJntPos,m_startJntPos,m_endJntPos :Vec7d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//Has the inverse kinematics been successfully solved
	m_IKSucceed:BOOL;	
	
	//original joint position
	m_originJntPos:Vec7d;
	
	//inverse kinematic idx
	m_IK:INT;
	
	//time
	m_time:LREAL;
	
	//arm id
	m_armId:INT;	
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec7d;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="activeJnt2DH" Id="{a8f34546-f91d-48aa-98e8-b014e5495029}">
      <Declaration><![CDATA[METHOD activeJnt2DH : BOOL
VAR_INPUT
	i_activeJntPos:Vec7d;
END_VAR

VAR_OUTPUT
	o_DHJntPos:Vec7d;
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
o_DHJntPos:=i_activeJntPos;
o_DHJntPos[3]:=i_activeJntPos[3]-i_activeJntPos[2]; //q8 = q3+q2-----q3=q8-q2
o_DHJntPos[4]:=i_activeJntPos[4]+i_activeJntPos[3]-i_activeJntPos[2]-pi/2; //q4DH=q4motor+q8-q2-90; ----q4motor=q4DH+q2-q8+90
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{b549ed00-ec1a-412a-94d0-63a741bf9608}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
IF (GVL_AccuracyTestVar.g_MSPrecisionTest[i_masterArm.armIdx]=FALSE) THEN
	IF i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeS OR 
		i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeU THEN
		calcCmdJntPos_USKnife(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	ELSE
		calcCmdJntPos_BasicInstru(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	END_IF
ELSE
	//All joints are in position mode
	calcCmdJntPos_BasicInstru_Test(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_BasicInstru" Id="{239c44da-fbb4-4bf5-8dd0-8022d66af60b}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_BasicInstru : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_cmdJntPos:=i_masterArm.curJntPos;
m_cmdJntVel:=i_masterArm.curJntVel;
m_cmdCartPose:=i_masterArm.curCartPose;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_BasicInstru_Test" Id="{7e13d979-67ea-4ada-b011-d0dc90d8ce97}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_BasicInstru_Test : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=inverseKinematic(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=5;
		END_IF		
		
		
	5: //pause and confirm
		IF (m_motionCycleNum=1) AND (m_pointNum=1) THEN
			IF (GVL_AccuracyTestVar.g_startMotion[m_armId]=TRUE) THEN
				m_testStep:=10;
			END_IF
		ELSE
			m_testStep:=10;
		END_IF
		
		
	10: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=15;
		END_IF
		
		
	15: //Waiting for confirmation and measurement
		IF (GVL_AccuracyTestVar.g_nextStep[m_armId]=TRUE) THEN
			GVL_AccuracyTestVar.g_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
		
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
		
		
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_AccuracyTest.g_testMotCycNum) THEN
				m_testStep:=60;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
		
		
	60: //stop
		m_testStep:=-1;
END_CASE



GVL_AccuracyTestVar.g_curStep[m_armId]:=m_testStep;
GVL_AccuracyTestVar.g_testPointId[m_armId]:=m_pointNum;
GVL_AccuracyTestVar.g_testCycleId[m_armId]:=m_motionCycleNum;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_USKnife" Id="{e3490571-181c-4e3a-9266-10457d84eb98}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_USKnife : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR CONSTANT
	// orientation tracking parameters
	m_rotTrackKp : LREAL := 200;
	m_maxTrackVel :LREAL := PI;
	m_trackAngThres :LREAL := 2* g_deg2rad;
END_VAR
VAR 
	cartTrackVel :Vec3d;
	i,j : INT;
	invRot :Mat3d;
	cmdRotInView:Mat3d;
	rotT,rotErr :Mat3d;
	angle:LREAL;
	axis:Vec3d;
	
	oriJaco:Mat34;
	oriJt:Mat43;
	oriJJt:Mat3d;
	oriJJtInv:Mat3d;
	oriJPinv:Mat43;
	jntTrackVel:Vec4d;
	JpinvJ, nullJ:Mat4d;
	eye4d :Mat4d := g_eye4d;
	redunCtrlVel :Vec4d;
	jnt4TrackVel :LREAL;
	cmdZAxis, curZAxis :Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_jntOPMode[1] := DriverOPMode_Trq;
m_jntOPMode[2] := DriverOPMode_Trq;
m_jntOPMode[3] := DriverOPMode_Trq;
m_jntOPMode[4] := DriverOPMode_PosTrq;
m_jntOPMode[5] := DriverOPMode_PosTrq;
m_jntOPMode[6] := DriverOPMode_PosTrq;
m_jntOPMode[7] := DriverOPMode_Trq;

// use matched slave arm orientation as target, 
//	and transform from view coordinate to arm coordinate 
cmdRotInView := i_slaveStatus.m_curArmPose[i_slaveIdx].m_rot;
matTranspose(i_shoulderPose.m_rot, invRot);
matMultiply(invRot, cmdRotInView, m_cmdCartPose.m_rot);
m_cmdCartPose.m_pos:= i_masterArm.curCartPose.m_pos;

// first three joints and joint7 is passive control
FOR i:=1 TO 3 DO 
	m_cmdJntPos[i]:=i_masterArm.curJntPos[i];
	m_cmdJntVel[i]:=i_masterArm.curJntVel[i];
END_FOR
m_cmdJntPos[7]:=i_masterArm.curJntPos[7];
m_cmdJntVel[7]:=i_masterArm.curJntVel[7];

// compute cartesian tracking velocity
FOR i:=1 TO 3 DO
	cmdZAxis[i] :=  m_cmdCartPose.m_rot[i,3];
	curZAxis[i] := i_masterArm.simCartPose.m_rot[i,3];
END_FOR
angle := ACOS(LIMIT(-1,vecDot(cmdZAxis,curZAxis),1));
axis := cross(curZAxis, cmdZAxis);
IF ABS(angle)> g_smallAng AND ABS(angle-pi)> g_smallAng THEN
	normalize(axis);
END_IF
vecMultiNum(axis, LIMIT(-m_maxTrackVel, angle*m_rotTrackKp, m_maxTrackVel), cartTrackVel);

// compute pinv of orientation jacobian
FOR i:=1 TO 3 DO
	FOR j:=1 TO 4 DO
		oriJaco[i,j]:=i_masterArm.simJaco[i+3,j+3];
	END_FOR
END_FOR
matTranspose(oriJaco, oriJt);
matMultiply(oriJaco ,oriJt , oriJJt);
invMat3(oriJJt, oriJJtInv);
matMultiply(oriJt, oriJJtInv, oriJPinv);
matMultiVec(oriJpinv, cartTrackVel, jntTrackVel);

// calculate nullspace
matMultiply(oriJPinv, oriJaco, JpinvJ);
matSub(eye4d , JpinvJ, nullJ);

// redundant velocity
jnt4TrackVel:=calcRedunVel(i_masterArm);
redunCtrlVel[1]:=nullJ[1,1]*jnt4TrackVel;
redunCtrlVel[2]:=nullJ[2,1]*jnt4TrackVel;
redunCtrlVel[3]:=nullJ[3,1]*jnt4TrackVel;
redunCtrlVel[4]:=nullJ[4,1]*jnt4TrackVel;

// update final command joint position and velocity
FOR i :=1 TO 3 DO 
	m_cmdJntVel[i+3]:=jntTrackVel[i]+redunCtrlVel[i];
	m_cmdJntPos[i+3]:=m_cmdJntPos[i+3]+m_cmdJntVel[i+3]*g_armCtrlCycleTime;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq" Id="{590b7c96-65ed-47d5-8eb2-8a13ee8a5533}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeS OR 
	i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeU THEN
	calcCmdJntTrq_USKnife(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
ELSE
	calcCmdJntTrq_BasicInstru(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq_BasicInstru" Id="{924c67b8-8dc8-4b14-a8ff-535af80c10ba}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq_BasicInstru : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	nullspaceMat :Mat7d;
	ctrlTrq : Vec7d;
	boundaryTrq :Vec7d;
	withinBoundary :BOOL;
	joint6LimitTrq:LREAL;
	i :INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// boundary force feedback
m_boundaryTrq :=m_boundaryForce.run(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
withinBoundary := (norm(m_boundaryTrq)<g_smallNum);

// redundant joint4 controller
ctrlTrq := g_zeroVec7d;
ctrlTrq[4] := m_redunJntCtrl.run(i_masterArm, i_followEnable:=withinBoundary);

// project to nullspace
IF m_nullspaceCtrl THEN
	nullspaceMat:=i_masterArm.dynaNullspace;
	matMultiVec(nullspaceMat,ctrlTrq, m_cmdJntTrq);
	vecSelfMultiNum(m_cmdJntTrq, ctrlTrq[4] / m_cmdJntTrq[4]);
ELSE
	m_cmdJntTrq := ctrlTrq;
END_IF

// add friction compensation
FOR i:=1 TO g_mJntNum DO 
	m_cmdJntTrq[i] := m_cmdJntTrq[i] +m_frictionCompScale * i_masterArm.jntFriction[i] + m_boundaryTrq[i];
END_FOR

// joint6  limit control
joint6LimitTrq := m_jnt6LimitCtrl.run(i_masterArm);
m_cmdJntTrq[6]:= m_cmdJntTrq[6]+ joint6LimitTrq;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq_USKnife" Id="{89963b71-7e72-4bb1-9f43-b099432ea948}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq_USKnife : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	i :INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_cmdJntTrq :=g_zeroVec7d;
// boundary force feedback
m_boundaryTrq :=m_boundaryForce.run(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
m_cmdJntTrq[7] := m_boundaryTrq[7];
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcRedunVel" Id="{2d8bb2ec-2a44-4bc5-9d2d-80c4739e4cf3}">
      <Declaration><![CDATA[METHOD PROTECTED calcRedunVel : LREAL
VAR_IN_OUT CONSTANT
	i_masterArm :FB_MasterArm;
END_VAR

VAR 
	// redundant control parameters
	m_jnt4AdjustKp : LREAL :=10;
	m_jnt4MaxVel :LREAL :=pi/3 ;
	m_linearVelLb :LREAL := 0.02;
	m_linearVelUb :LREAL :=0.1;	
	
	j6Bias,j5Bias :LREAL;
	velScale :LREAL;
	linearVel :Vec3d;
	curJntPos : Vec7d;
	jnt4LinkPos :LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// compute desired joint4 link position
curJntPos :=  i_masterArm.cmdJntPos;
jnt4LinkPos:=i_masterArm.jnt4MotorToLink(curJntPos[2],curJntPos[3],curJntPos[4]);
IF 1= i_masterArm.armIdx THEN
	j6Bias :=curJntPos[6]+PI/2;
ELSE 
	j6Bias := curJntPos[6]-PI/2;
END_IF

// scale based on joint5 position
j5Bias :=  LIMIT (0, ABS(curJntPos[5] -pi), pi/2);
j6Bias := j6Bias * ABS(COS(j5Bias));

// scale based on linear velocity
linearVel[1]:=i_masterArm.curCartTwist[1];
linearVel[2]:=i_masterArm.curCartTwist[2];
linearVel[3]:=i_masterArm.curCartTwist[3];
velScale :=LIMIT(0, (norm(linearVel)-m_linearVelLb)/(m_linearVelUb-m_linearVelLb),1.0);


calcRedunVel := LIMIT(-m_jnt4MaxVel, -j6Bias * m_jnt4AdjustKp * velScale ,m_jnt4MaxVel);

// joint limit
IF (calcRedunVel > 0 AND jnt4LinkPos+calcRedunVel * g_armCtrlCycleTime > GVL_ArmJointParameters.g_maxJntPos[i_masterArm.armIdx,4])
	 OR ( calcRedunVel <0 AND  jnt4LinkPos +calcRedunVel * g_armCtrlCycleTime< GVL_ArmJointParameters.g_minJntPos[i_masterArm.armIdx,4]) THEN
	 calcRedunVel :=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="DH2activeJnt" Id="{25602d6a-7716-48d1-a65a-afd611518d1b}">
      <Declaration><![CDATA[METHOD DH2activeJnt : BOOL
VAR_INPUT
	i_DHJntPos:Vec7d;
END_VAR
VAR_OUTPUT
	o_activeJntPos:Vec7d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
o_activeJntPos:=i_DHJntPos;
o_activeJntPos[3]:=i_DHJntPos[3]+i_DHJntPos[2]; //  q8 = q3+q2
o_activeJntPos[4]:=i_DHJntPos[4]+i_DHJntPos[2]-o_activeJntPos[3]+pi/2; //q4DH=q4motor+q8-q2-90; ----q4motor=q4DH+q2-q8+90
]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{1bea1de4-0538-46fc-be44-e671d6da03c3}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

IF (GVL_AccuracyTestVar.g_MSPrecisionTest[i_masterArm.armIdx]=FALSE) THEN
	m_jntOPMode := g_allTrqMode;
ELSE
	//m_jntOPMode := g_allPosMode; //All joints are in position mode
	m_jntOPMode:=g_allPosTrqMode;
END_IF

// init controller
m_redunJntCtrl.init(i_masterArm);
m_jnt6LimitCtrl.init(i_masterArm);

// update commands to arm
copyCmds(r_masterArmCtrlCmd);

//variable initialization
m_armId:=i_masterArm.armIdx;

//init IK idx
IF (m_armId=1) THEN
	m_IK:=4;
ELSE
	m_IK:=3;
END_IF

//motion parameters initial
motionParamInit(i_masterArm);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="inverseKinematic" Id="{0a4b73dc-2d9a-4c99-8d88-a71a543f8719}">
      <Declaration><![CDATA[METHOD inverseKinematic : BOOL
VAR_INPUT	
	i_masterArm :FB_MasterArm;
	i_q4:LREAL;
	i_targetFrame:ST_Frame;
END_VAR

VAR_OUTPUT
	o_targetJntPos:Vec7d;
END_VAR

VAR
	i:INT;
	IKSucceed:BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Call inverse kinematics
IKSucceed:=i_masterArm.inverseKinematic(q4:= i_q4, solution_ID:= m_IK, i_curCartPose:= i_targetFrame, r_jntPos:= o_targetJntPos);
IF (IKSucceed=FALSE) THEN
	inverseKinematic:=FALSE;
	RETURN;
END_IF


//Constrained solution range
//For joint 5, the initial position is at 180 degrees, and the range of motion is different from the output range of the atan2 function. Here, the solution results are standardized
minimumDistMot(i_current:= pi, i_target:= o_targetJntPos[5], o_target=> o_targetJntPos[5]);


//Determine whether the solution result is appropriate
FOR i:=1 TO g_mJntNum BY 1 DO
	IF (o_targetJntPos[i]>GVL_ArmJointParameters.g_maxJntPos[m_armId,i]) OR (o_targetJntPos[i]<GVL_ArmJointParameters.g_minJntPos[m_armId,i]) THEN
		inverseKinematic:=FALSE;
		RETURN;
	END_IF
END_FOR
inverseKinematic:=TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="minimumDistMot" Id="{3b012980-c19b-4345-a805-1924c0d66789}">
      <Declaration><![CDATA[METHOD minimumDistMot : BOOL
VAR_INPUT
	i_current:LREAL;
	i_target:LREAL;
END_VAR
VAR_OUTPUT
	o_target:LREAL;
END_VAR
VAR
	p1,p2,p3,p4:LREAL;
	d1,d2,d3:LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
p1:=i_current;

p2:=i_target;            d1:=ABS(p2-p1);
p3:=i_target+2*pi;      d2:=ABS(p3-p1);
p4:=i_target-2*pi;       d3:=ABS(p4-p1);

IF (d1<d2 AND d1<d3) THEN
	o_target:=p2;
ELSIF (d2<d1 AND d2<d3) THEN
	o_target:=p3;
ELSE
	o_target:=p4;
END_IF



]]></ST>
      </Implementation>
    </Method>
    <Method Name="motionParamInit" Id="{1c62ec81-0165-4205-bce0-f3ebfd921b2f}">
      <Declaration><![CDATA[METHOD motionParamInit : BOOL
VAR_INPUT
	// arm data
	i_masterArm:FB_MasterArm;
END_VAR
VAR
	i,j:INT;
	poseVec:Vec6d;
	originPose:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_testStep:=0;
m_time:=0;


//velocity---acceleration---jerk
vecMultiNum(GVL_ArmJointParameters.g_maxJntVel,0.2,m_maxjntVel);
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);


//accuracy test variables
m_pointNum:=1;
m_pointSum:=8;
m_motionCycleNum:=1;


//original joint position
FOR i:=1 TO g_mJntNum BY 1 DO
	m_originJntPos[i]:=GVL_ArmJointCaliData.g_linkEncCaliJntPos[m_armId,i];
END_FOR


//test point record
IF (m_armId=1) THEN
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA1;
ELSE
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA2;
END_IF


//Accuracy testing target position
FOR i:=1 TO GVL_AccuracyTest.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_targetPosVecArr[i,j];
	END_FOR
	xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_targetPosArr[i]);
	i_masterArm.forwardKinematic(m_originJntPos,originPose);
	m_targetPosArr[i].m_rot:=originPose.m_rot;
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="rpy2rot" Id="{d5882716-ae95-4e1b-a001-2e7ad7afc648}">
      <Declaration><![CDATA[METHOD rpy2rot : BOOL
VAR_INPUT
	i_rpy:Vec3d;
END_VAR

VAR_OUTPUT
	o_rot:Mat3d;
END_VAR

VAR
	rot_x,rot_y,rot_z:LREAL;
	alpha,beta,gama:LREAL;
	matrix_out:ARRAY[1..3,1..3] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
alpha:=rot_z;
beta:=rot_y;
gama:=rot_x;

matrix_out[1,1]:=COS(alpha)*COS(beta);
matrix_out[2,1]:=SIN(alpha)*COS(beta);
matrix_out[3,1]:=-SIN(beta);

matrix_out[1,2]:=COS(alpha)*SIN(beta)*SIN(gama)-SIN(alpha)*COS(gama);
matrix_out[2,2]:=SIN(alpha)*SIN(beta)*SIN(gama)+COS(alpha)*COS(gama);
matrix_out[3,2]:=COS(beta)*SIN(gama);

matrix_out[1,3]:=COS(alpha)*SIN(beta)*COS(gama)+SIN(alpha)*SIN(gama);
matrix_out[2,3]:=SIN(alpha)*SIN(beta)*COS(gama)-COS(alpha)*SIN(gama);
matrix_out[3,3]:=COS(beta)*COS(gama);

o_rot:=matrix_out;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="xyzrpy2Frame" Id="{d3f10344-e166-4183-b0f6-d23b41223079}">
      <Declaration><![CDATA[METHOD xyzrpy2Frame : BOOL
VAR_INPUT
	i_posVec:Vec6d;
END_VAR

VAR_OUTPUT
	o_frame:ST_Frame;
END_VAR

VAR
	i:INT;
	rpyVec:Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
FOR i:=1 TO 3 BY 1 DO
	o_frame.m_pos[i]:=i_posVec[i];
	rpyVec[i]:=i_posVec[i+3];
END_FOR
rpy2rot(i_rpy:= rpyVec, o_rot=> o_frame.m_rot) ;

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlMasterSlave">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.activeJnt2DH">
      <LineId Id="23" Count="0" />
      <LineId Id="20" Count="0" />
      <LineId Id="22" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="24" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos">
      <LineId Id="141" Count="1" />
      <LineId Id="149" Count="4" />
      <LineId Id="143" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="147" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="144" Count="0" />
      <LineId Id="124" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_BasicInstru">
      <LineId Id="14" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="111" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_BasicInstru_Test">
      <LineId Id="134" Count="1" />
      <LineId Id="137" Count="17" />
      <LineId Id="318" Count="2" />
      <LineId Id="324" Count="1" />
      <LineId Id="322" Count="1" />
      <LineId Id="321" Count="0" />
      <LineId Id="316" Count="1" />
      <LineId Id="311" Count="4" />
      <LineId Id="160" Count="8" />
      <LineId Id="213" Count="0" />
      <LineId Id="219" Count="15" />
      <LineId Id="214" Count="2" />
      <LineId Id="170" Count="9" />
      <LineId Id="246" Count="1" />
      <LineId Id="180" Count="5" />
      <LineId Id="277" Count="1" />
      <LineId Id="197" Count="0" />
      <LineId Id="251" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="199" Count="0" />
      <LineId Id="264" Count="0" />
      <LineId Id="111" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_USKnife">
      <LineId Id="382" Count="62" />
      <LineId Id="131" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq">
      <LineId Id="223" Count="4" />
      <LineId Id="13" Count="0" />
      <LineId Id="246" Count="0" />
      <LineId Id="245" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq_BasicInstru">
      <LineId Id="204" Count="1" />
      <LineId Id="202" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="182" Count="3" />
      <LineId Id="228" Count="1" />
      <LineId Id="227" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq_USKnife">
      <LineId Id="243" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="244" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcRedunVel">
      <LineId Id="77" Count="1" />
      <LineId Id="113" Count="0" />
      <LineId Id="79" Count="4" />
      <LineId Id="125" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="134" Count="6" />
      <LineId Id="133" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="3" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.DH2activeJnt">
      <LineId Id="26" Count="1" />
      <LineId Id="29" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.init">
      <LineId Id="13" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="153" Count="4" />
      <LineId Id="115" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="59" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="128" Count="1" />
      <LineId Id="127" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="158" Count="10" />
      <LineId Id="91" Count="0" />
      <LineId Id="74" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.inverseKinematic">
      <LineId Id="26" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.minimumDistMot">
      <LineId Id="6" Count="0" />
      <LineId Id="17" Count="13" />
      <LineId Id="7" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.motionParamInit">
      <LineId Id="10" Count="1" />
      <LineId Id="122" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="26" Count="3" />
      <LineId Id="107" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="108" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="73" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="36" Count="6" />
      <LineId Id="66" Count="0" />
      <LineId Id="45" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.rpy2rot">
      <LineId Id="7" Count="0" />
      <LineId Id="21" Count="7" />
      <LineId Id="30" Count="2" />
      <LineId Id="34" Count="3" />
      <LineId Id="39" Count="0" />
      <LineId Id="8" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.xyzrpy2Frame">
      <LineId Id="7" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="32" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="26" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>