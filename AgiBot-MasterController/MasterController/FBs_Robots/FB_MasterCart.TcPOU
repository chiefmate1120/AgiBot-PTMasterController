<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_MasterCart" Id="{05baaa0e-c853-48bc-a37c-d593cfa5bf2b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MasterCart
VAR
	//  IO and check
	m_endoScopePedalIO AT%I* :BOOL;
	m_endoScopeIOCheck :FB_IOCheck;
	
	m_clutchPedalIO AT%I* :BOOL;
	m_clutchIOCheck :FB_IOCheck;
	
	m_surgonHeadInIO AT%I* :BOOL;
	m_headInCheck:FB_IOCheck;
	
	m_armSwitchIO AT%I* :BOOL;
	m_armSwitchCheck:FB_IOToggleCheck;
	
	m_electricCutLeft AT %I* :BOOL;
	m_electricCutLeftAllow AT %I* :BOOL;
	
	m_electricCutRight AT %I* :BOOL;
	m_electricCutRightAllow AT %I* :BOOL;
	
	m_electricCoagulLeft AT %I* :BOOL;
	m_electricCoagulLeftAllow AT %I* :BOOL;
	
	m_electricCoagulRight AT %I* :BOOL;
	m_electricCoagulRightAllow AT %I* :BOOL;
	
	m_elecKnifeCtrlWord AT %Q* :DINT;
	
	// cart status
	m_cartStatus  : ST_CartStatus;
	
	// cart joints
	// [monitor lift, monitor rotate, armset, pedal]
	m_cartJoints:ARRAY[1..4] OF FB_CartJoint;
	
	// cart joint motion control IO
	//[monitor_up, monitor_down, monitor_cwRotate, monitor_ccwRotate, armset_up, armset_down, pedal_in, pedal_out]
	m_cartJointCtrlIO AT%I* :ARRAY[1..8] OF BOOL ;
	m_cartJointCtrlIOCheck :ARRAY[1..8] OF FB_IOCheck;
	
	//electrotome control io
	m_electricCutLeftOn :BOOL;
	m_electricCutRightOn :BOOL;
	m_electricCoagulLeftOn : BOOL;
	m_electricCoagulRightOn : BOOL;
	//Triggering several energies at once
	m_eleCtrlState : UINT;
	//The type of instrument energy of the master hand corresponding to the slave hand
	m_energyType :ARRAY[1..g_mArmNum] OF UINT :=[2(0)];
	
	// cart joint control data
	m_jntEnableCounts:Vec4i ;
	m_jntDisableCounts:Vec4i ;
	m_jntEnableCountsThres:INT:=500;
	m_jntCmdMotionDir :Vec4i;
	m_cmdJntTrq :Vec4d;
	m_cmdJntPos :Vec4d;
	m_cmdJntVel :Vec4d;
	m_jntEnableFlag :Vec4b;
	
	//cart ergonomic adjust data
	m_UIData : ST_CartUIData;
	m_carInMotion : INT; // 0:  no mition, 1: mamual adjust, 2: ergonomic adjust
	m_jntSoftwareLimit :ARRAY [1..4] OF LREAL := [0.01, 1*g_deg2Rad, 0.015, 0.005];
	m_cmdArrival : Vec4b;
	
	// cart joint status data
	m_curMotorPos :Vec4d;
	m_curLinkPos :Vec4d;
	m_curJntPos :Vec4d;
	m_curJntVel :Vec4d;
	m_curJntTrq :Vec4d;
	m_rawJntCurrent :Vec4d;
	m_filtJntCurrent :Vec4d;
	m_cmdJntCurrent : Vec4d;

	
	
	
	
	//**************************add code for test****************************//
	//test step
	m_testStep:INT:=-1;
	
	//motion start
	m_startMotion:BOOL;
	m_startMotionLast:BOOL;
	
	//time
	m_time:LREAL;
	
	//test point
	m_pointNum:INT;
	
	//DH joint position	
	m_homeDHJntPos,m_startDHJntPos,m_endDHJntPos:Vec4d;
	
	//startJntPos,endJntPos
	m_initJntPos,m_startJntPos,m_endJntPos :Vec7d;
	
	//joint position gap---监视器升降  监视器旋转  扶手升降  脚踏伸缩
	m_jntDist:Vec4d:=[0,0,0,0];	
	
	//planner
	m_Planner: FB_TrajMoveJ;
	
	//trajectory velocity/acceleration/jerk
	m_maxjntVel:Vec7d;
	m_maxjntAcc:Vec7d;
	m_maxjntJerk:Vec7d;
	m_jntCtrlMotionVel :ARRAY[1..7] OF LREAL :=[0.015,2*g_deg2Rad,0.01,0.0075,0.1,0.1,0.1];
	
	//arm id
	m_armId:INT:=1;	
	
	//target joint position
	m_targetJntPos:ARRAY[1..10] OF Vec4d;
	
	//point sum
	m_pointSum:INT;
	
	//target cycle number
	m_motionCycleNum:INT;
	m_targetCycleNum:INT;
	
	
	
	
	//*********************add code for joint position test**************************//
	//test step
	m_testStepJntPos:INT:=-1;
	
	//motion start
	m_jntTestStartMotion:BOOL;
	m_jntTestStartMotionLast:BOOL;
	
	
	//*********************add code for joint current test**************************//
	//test step
	m_jntCurTestStep:INT:=-1;
	
	//motion start
	m_jntCurTestStart:BOOL;
	m_jntCurTestStartLast:BOOL;
	
	//motor parameters
	m_motorReduction :LREAL;
	m_trqConst :LREAL;
	m_motorDir :INT;
	m_trq2CurrentRatio:LREAL;
	m_current2TrqRatio:LREAL;
	m_armCurrent2TrqRatio:Vec4d;	
	
	//unit function
	m_unitFun:FB_UnitTransform;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Folder Name="property" Id="{37b9f91a-fbe1-4cae-807d-574d49e247d7}" />
    <Method Name="cartTestCycle" Id="{ebc1a974-4490-4236-8e5f-48d6f3582755}">
      <Declaration><![CDATA[METHOD cartTestCycle : BOOL
VAR_INPUT
	
END_VAR

VAR
	i:INT;
	homeDHPos,startDHPos,endDHPos :Vec4d;
	cmdJntPos,cmdJntVel,cmdJntAcc:Vec7d;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//init parameters flag
IF (g_cycleTest.m_carEnterESDTest=TRUE) THEN
	m_startMotion:=TRUE;
ELSE
	m_startMotion:=g_cycleTest.m_startMotionCar AND g_cycleTest.m_carEnterCycleTest;
END_IF

//monitoring signal rising edge
IF (m_startMotionLast=FALSE) AND (m_startMotion=TRUE)THEN
	m_testStep:=0;
END_IF
m_startMotionLast:=m_startMotion;



CASE m_testStep OF
	0: //init
		m_pointNum:=1;
		m_testStep:=10;
		
		//target DH joint position
		FOR i:=1 TO 4 BY 1 DO
			m_homeDHJntPos[i]:=(GVL_CartJointParameters.g_minJntPos[i]+GVL_CartJointParameters.g_maxJntPos[i])/2;
			m_jntDist[i]:=(GVL_CartJointParameters.g_maxJntPos[i]-GVL_CartJointParameters.g_minJntPos[i])*0.1;
			m_startDHJntPos[i]:=m_homeDHJntPos[i]-m_jntDist[i];
			m_endDHJntPos[i]:=m_homeDHJntPos[i]+m_jntDist[i];
		END_FOR
		
		//velocity and acceleration
		vecMultiNum(m_jntCtrlMotionVel,0.3,m_maxjntVel);
		vecMultiNum(m_maxjntVel,5,m_maxjntAcc);
		vecMultiNum(m_maxjntAcc,5,m_maxjntJerk);
		
		IF (g_cycleTest.m_carEnterESDTest=FALSE) THEN
			m_pointSum:=g_cycleTest.m_pointSumCar;
			m_targetCycleNum:=g_cycleTest.m_targetCycleNumCar;
			FOR i:=1 TO 10 BY 1 DO
				m_targetJntPos[i]:=m_unitFun.carUnit2System(i_dataTest:= g_cycleTest.m_targetJntPosCar[i]);
			END_FOR			
		ELSE
			m_pointSum:=3;
			m_targetCycleNum:=30000;
			m_targetJntPos[1]:=m_startDHJntPos; 	m_targetJntPos[2]:=m_homeDHJntPos;	m_targetJntPos[3]:=m_endDHJntPos;			
		END_IF
								
		
	10: //Trajectory parameter initialization
		startDHPos:=m_curJntPos;
		endDHPos:=m_targetJntPos[m_pointNum];				
		
		FOR i:=4 TO 7 BY 1 DO
			m_startJntPos[i]:=startDHPos[i-3];
			m_endJntPos[i]:=endDHPos[i-3];
		END_FOR		
		
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=30;
		ELSE
			m_time:=0; m_testStep:=20;
		END_IF
	
		
	20: //start motion
		IF (g_cycleTest.m_pauseCar=TRUE) THEN
			g_cycleTest.m_pauseCar:=FALSE;
			RETURN;
		END_IF
		
		IF (g_cycleTest.m_finishCar=TRUE) THEN
			g_cycleTest.m_finishCar:=FALSE;
			m_testStep:=30;
			RETURN;
		END_IF	
		
		m_time:=m_time+g_cartCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> cmdJntPos, jntVel=> cmdJntVel, jntAcc=> cmdJntAcc);
		FOR i:=1 TO 4 BY 1 DO
			m_cmdJntPos[i]:=cmdJntPos[i+3];
			m_cmdJntVel[i]:=cmdJntVel[i+3];
		END_FOR
		
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=25;			
		END_IF		
		
		//end the motion
		IF (m_startMotion=FALSE) THEN
			m_testStep:=30;
		END_IF
		
		
	25: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>m_targetCycleNum) THEN
				m_testStep:=30;
			ELSE
				m_testStep:=10;
			END_IF
		ELSE
			m_testStep:=10;
		END_IF		
		
	
	30: //end the motion
		m_testStep:=-1;	
	
	
	-1: //
END_CASE



//update the encoder information
FOR i:=1 TO 4 BY 1 DO
	g_cycleTest.m_cartMotorEncoder[i]:=m_cartJoints[i].m_motorInputs.m_motorEncoder;
	g_cycleTest.m_cartJntEncoder[i]:=m_cartJoints[i].m_motorInputs.m_linkEncoder;
END_FOR

//update the joint position
//g_cycleTest.m_carJntPos:=m_curJntPos;
g_cycleTest.m_carJntPos:=m_unitFun.carArmUnit2User(i_dataSystem:= m_curJntPos);

GVL_Monitor.carTestStep:=m_testStep;
GVL_Monitor.carTestPoint:=m_pointNum;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="cartTestJnt" Id="{4b30d635-bf84-46c0-bab5-01b89400ffe1}">
      <Declaration><![CDATA[METHOD cartTestJnt : BOOL
VAR_INPUT
	
END_VAR

VAR
	i:INT;
	homeDHPos,startDHPos,endDHPos :Vec4d;
	cmdJntPos,cmdJntVel,cmdJntAcc:Vec7d;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//init parameters flag
m_jntTestStartMotion:=g_motionTest.m_startMotionCar;
IF (m_jntTestStartMotionLast=FALSE) AND (m_jntTestStartMotion=TRUE)THEN
	m_testStepJntPos:=0;
END_IF
m_jntTestStartMotionLast:=m_jntTestStartMotion;


CASE m_testStepJntPos OF 
	0: //Trajectory parameter initialization		 
		startDHPos:=m_curJntPos;				
		IF (g_motionTest.m_jntPosIncModeCar=FALSE) THEN
			FOR i:=4 TO 7 BY 1 DO
				m_maxjntVel[i]:=g_motionTest.m_targetJntVelCar[i-3];
			END_FOR
			endDHPos:=g_motionTest.m_targetJntPosCar;
		ELSE
			vecMultiNum(m_jntCtrlMotionVel,0.3,m_maxjntVel);
			vecAdd(startDHPos,g_motionTest.m_targetJntPosIncCar,endDHPos);
		END_IF
		
		//velocity and acceleration
		vecMultiNum(m_maxjntVel,5,m_maxjntAcc);
		vecMultiNum(m_maxjntAcc,5,m_maxjntJerk);				
		m_testStepJntPos:=10;	
		
		
	10: //init trajectory
		FOR i:=4 TO 7 BY 1 DO
			m_startJntPos[i]:=startDHPos[i-3];
			m_endJntPos[i]:=endDHPos[i-3];
		END_FOR		
		
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStepJntPos:=30;
		ELSE
			m_time:=0; m_testStepJntPos:=20;
		END_IF
		
		
	20: //start motion
		m_time:=m_time+g_cartCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> cmdJntPos, jntVel=> cmdJntVel, jntAcc=> cmdJntAcc);
		FOR i:=1 TO 4 BY 1 DO
			m_cmdJntPos[i]:=cmdJntPos[i+3];
			m_cmdJntVel[i]:=cmdJntVel[i+3];
		END_FOR
		
		IF (m_time>m_Planner.duration) THEN
			m_testStepJntPos:=30;			
		END_IF
		
		
	30: //end the motion
		m_testStepJntPos:=-1;	
		//g_motionTest.m_enterJntTestCar:=FALSE;
		
		
	-1: //
END_CASE

//update the joint position
g_motionTest.m_carJntPos:=m_curJntPos;
g_motionTest.m_carJntCurrent:=m_filtJntCurrent;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="cartTestJntCurrent" Id="{bb8f7dbd-4d8b-4b2a-a3d9-0f8fe1c4a5e6}">
      <Declaration><![CDATA[METHOD cartTestJntCurrent : BOOL
VAR_INPUT
	
END_VAR

VAR
	i:INT;
	i_jntIdx:INT;
	targetTrq:ARRAY[1..4] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//init parameters flag
m_jntCurTestStart:=g_motionTest.m_carJntCurTest;
IF (m_jntCurTestStartLast=FALSE) AND (m_jntCurTestStart=TRUE)THEN
	m_jntCurTestStep:=0;
END_IF
m_jntCurTestStartLast:=m_jntCurTestStart;


CASE m_jntCurTestStep OF 
	0: //init
		FOR i_jntIdx:=1 TO 4 BY 1 DO
			m_motorReduction :=GVL_ArmJointParameters.g_motorReduction[i_jntIdx];
			m_trqConst :=GVL_ArmJointParameters.g_motorTrqConst[i_jntIdx];
			m_motorDir :=GVL_ArmJointParameters.g_motorDir[m_armId,i_jntIdx];
			m_trq2CurrentRatio:=m_motorDir * 1000.0/(m_trqConst*m_motorReduction);
			m_current2TrqRatio:=m_motorDir * (m_trqConst*m_motorReduction)/1000.0;
			m_armCurrent2TrqRatio[i_jntIdx]:=m_current2TrqRatio;
		END_FOR
		m_jntCurTestStep:=10;
		
		
	10: //update the current
		FOR i:=1 TO 4 BY 1 DO			
			targetTrq[i]:=g_motionTest.m_targetJntCurrentCar[i]*m_armCurrent2TrqRatio[i];			
		END_FOR
		m_cmdJntTrq:=targetTrq;		
		IF (g_motionTest.m_carJntCurTest=FALSE) THEN
			m_jntCurTestStep:=20;
		END_IF
		
		
	20: //finish
		m_jntCurTestStep:=-1;
	
	
	-1: //
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="eleKnifeCtrl" Id="{802e30d4-05e6-4f42-9cf9-00572025b770}">
      <Declaration><![CDATA[METHOD eleKnifeCtrl : DINT
VAR_IN_OUT CONSTANT
	m_armState:ARRAY[1..g_mArmNum] OF E_masterArmState ;
	m_teleSlaveArmIdx :ARRAY[1..g_mArmNum] OF E_MatchedSlaveArmIdx;
	m_instruStauts: ARRAY[1..g_sArmNum] OF ST_InstruStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Foot trigger check
m_electricCutLeftOn := m_electricCutLeft AND m_electricCutLeftAllow AND m_armState[1] = MasterArmState_MasterSlave ;
m_electricCutRightOn := m_electricCutRight AND m_electricCutRightAllow AND m_armState[2] = MasterArmState_MasterSlave ;
m_electricCoagulLeftOn := m_electricCoagulLeft AND m_electricCoagulLeftAllow AND m_armState[1] = MasterArmState_MasterSlave ;
m_electricCoagulRightOn := m_electricCoagulRight AND m_electricCoagulRightAllow AND m_armState[2] = MasterArmState_MasterSlave ;

//You cannot excite two energies at the same time
m_eleCtrlState := BOOL_TO_UINT(m_electricCutLeftOn) + BOOL_TO_UINT(m_electricCutRightOn)
										 + BOOL_TO_UINT(m_electricCoagulLeftOn) + BOOL_TO_UINT(m_electricCoagulRightOn);

IF m_teleSlaveArmIdx[1] > 0 THEN
	m_energyType[1] := m_instruStauts[m_teleSlaveArmIdx[1]].m_energyType;
	m_energyType[2] := m_instruStauts[m_teleSlaveArmIdx[2]].m_energyType;
END_IF

IF m_eleCtrlState = 1 THEN
	IF (m_electricCutLeftOn AND  m_energyType[1] = InstruType_isMonopole) OR (m_electricCutRightOn AND  m_energyType[2] = InstruType_isMonopole) THEN
		eleKnifeCtrl := EnergyCtrlWord_isMonopoleCut;
	ELSIF (m_electricCoagulLeftOn AND m_energyType[1] = InstruType_isMonopole) OR (m_electricCoagulRightOn AND  m_energyType[2] = InstruType_isMonopole) THEN
		eleKnifeCtrl := EnergyCtrlWord_isMonopoleCoagul;
	ELSIF (m_electricCoagulLeftOn AND m_energyType[1] = InstruType_isBipolar) OR (m_electricCoagulRightOn AND  m_energyType[2] = InstruType_isBipolar) THEN
		eleKnifeCtrl := EnergyCtrlWord_isBipolarCoagul;
	ELSIF (m_electricCutLeftOn AND m_energyType[1] = InstruType_isUltraKnife) OR (m_electricCutRightOn AND  m_energyType[2] = InstruType_isUltraKnife) THEN
		eleKnifeCtrl := EnergyCtrlWord_isUltraMin;
	ELSIF (m_electricCoagulLeftOn AND m_energyType[1] = InstruType_isUltraKnife) OR (m_electricCoagulRightOn AND  m_energyType[2] = InstruType_isUltraKnife) THEN
		eleKnifeCtrl := EnergyCtrlWord_isUltraMax;
		
	ELSE
		eleKnifeCtrl := EnergyCtrlWord_NoOutput;
	END_IF
ELSE
	eleKnifeCtrl := EnergyCtrlWord_NoOutput;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ergonomicAdjust" Id="{2e585813-8b6a-4acc-85dd-29e49a47183d}">
      <Declaration><![CDATA[METHOD ergonomicAdjust : INT
VAR_INPUT
END_VAR
VAR
	i : INT;
	err:Vec4d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[vecSub(m_UIData.m_cmdJntPos,m_curJntPos, err);
ergonomicAdjust := 2;
//only update command after joints is truly enabled
FOR i := 1 TO 4 DO
	IF m_jntEnableFlag[i] AND m_cartJoints[i].isEnabled() AND m_jntEnableCounts[i]>= m_jntEnableCountsThres THEN
		m_cmdJntVel[i]:=sign(m_UIData.m_cmdJntPos[i]-m_cartJoints[i].jntPos)*(GVL_CartJointParameters.g_jntCtrlMotionVel[i]);
		IF ABS(err[i]) < m_jntSoftwareLimit[i]/3 THEN
			m_cmdJntVel[i]:=0;
		END_IF
		m_cmdJntPos[i] := LIMIT(GVL_CartJointParameters.g_minJntPos[i] + m_jntSoftwareLimit[i],  m_cmdJntPos[i] + m_cmdJntVel[i]*g_cartCtrlCycleTime, GVL_CartJointParameters.g_maxJntPos[i] - m_jntSoftwareLimit[i]);
	
	ELSE
		m_cmdJntVel[i]:=0;
		m_cmdJntPos[i] := m_cartJoints[i].jntPos;
	END_IF	
END_FOR




]]></ST>
      </Implementation>
    </Method>
    <Method Name="getStatus" Id="{3f39e291-1358-48a2-aa04-62d9bb4689e3}">
      <Declaration><![CDATA[METHOD PUBLIC getStatus : BOOL
VAR_IN_OUT
	// cart status data
	r_cartStatus :ST_CartStatus;
	
	// cart joint data
	r_cartJointData :ST_CartJointData;
	
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[r_cartStatus := m_cartStatus;


// current joint data
r_cartJointData.m_curMotorPos:=m_curMotorPos;
r_cartJointData.m_curLinkPos:=m_curLinkPos;
r_cartJointData.m_curJntPos:=m_curJntPos;
r_cartJointData.m_curJntVel:=m_curJntVel;
r_cartJointData.m_curJntTrq:=m_curJntVel;
r_cartJointData.m_rawJntCurrent:=m_rawJntCurrent;
r_cartJointData.m_filtJntCurrent:=m_filtJntCurrent;

// command joint data
r_cartJointData.m_cmdJntPos:=m_cmdJntPos;
r_cartJointData.m_cmdJntVel:=m_cmdJntVel;
r_cartJointData.m_cmdJntTrq:=m_cmdJntTrq;
r_cartJointData.m_cmdJntCurrent:=m_cmdJntCurrent;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="infoUpdate" Id="{184d313d-8cfa-436a-b9c0-a828c18f1825}">
      <Declaration><![CDATA[METHOD infoUpdate : BOOL
VAR_INPUT
END_VAR

VAR
	i: INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//update system information
FOR i:=1 TO 4 BY 1 DO
	//motor input and output information
	g_systemInfo.m_cartJntInfo[i].m_motorInput:=m_cartJoints[i].m_motorInputs;
	g_systemInfo.m_cartJntInfo[i].m_motorOutput:=m_cartJoints[i].m_motorOutputs;
	
	//joint position and max/min
	g_systemInfo.m_cartJntInfo[i].m_actJntPos:=m_curJntPos[i];
	g_systemInfo.m_cartJntInfo[i].m_jntMax:=GVL_CartJointParameters.g_maxJntPos[i];
	g_systemInfo.m_cartJntInfo[i].m_jntMin:=GVL_CartJointParameters.g_minJntPos[i];
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{a9830b95-e937-4a29-b70e-785e20452d37}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
	initLinkPos :LREAl;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// joint init
FOR i:=1 TO 4 DO
	m_cartJoints[i].init(i,g_cartCtrlCycleTime);
	m_cartJoints[i].initJntPos();
END_FOR

// motor and link encoder of  monitor rotation are on different  joints
// transfer monitor angle from link side to motor side
initLinkPos:= monitorAngLink2Motor(m_cartJoints[2].initLinkPos);
m_cartJoints[2].initJntPosReset(initLinkPos);

// init commands
FOR i:=1 TO 4 DO
	m_jntEnableCounts[i]:=0;
	m_jntDisableCounts[i]:=0;
	m_jntEnableFlag[i]:=FALSE;
	m_jntCmdMotionDir[i]:=0;
	m_cmdJntTrq[i]:=0;
	m_cmdJntVel[i]:=0;
	m_cmdJntPos[i]:=m_cartJoints[i].jntPos;
END_FOR

m_cartStatus.m_initFlag :=true;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="manualAdjust" Id="{9030940b-1f5c-4fe8-8e49-9b86403f7e35}">
      <Declaration><![CDATA[METHOD manualAdjust : INT
VAR_INPUT
END_VAR
VAR
	i : INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// update joint command positon
manualAdjust := 1;
//only update command after joints is truly enabled
FOR i := 1 TO 4 DO
	IF  m_jntEnableFlag[i] AND m_cartJoints[i].isEnabled() AND m_jntEnableCounts[i]>= m_jntEnableCountsThres THEN
		//  update command joint velocity
		m_cmdJntVel[i]:=m_jntCmdMotionDir[i]*GVL_CartJointParameters.g_jntCtrlMotionVel[i];
		
		// limit handle
		IF (m_cmdJntPos[i]> GVL_CartJointParameters.g_maxJntPos[i] - m_jntSoftwareLimit[i] AND m_cmdJntVel[i] >0 ) OR 
				(m_cmdJntPos[i]< GVL_CartJointParameters.g_minJntPos[i] + m_jntSoftwareLimit[i] AND m_cmdJntVel[i] <0 )  THEN
				m_cmdJntVel[i] := 0.0;
		END_IF
		m_cmdJntPos[i]:= m_cmdJntPos[i]+ m_cmdJntVel[i]*g_cartCtrlCycleTime;
	ELSE
		m_cmdJntVel[i]:=0;
		m_cmdJntPos[i] := m_cartJoints[i].jntPos;
	END_IF
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="monitorAngLink2Image" Id="{861c9491-a144-4c69-8a78-ffe9100ce0d2}">
      <Declaration><![CDATA[// TODO
METHOD PROTECTED monitorAngLink2Image : LREAL
VAR_INPUT
	i_linkPos:LREAL;
END_VAR
VAR
	A,B,C,D,E,F,G,H,I,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,Z0:LREAL;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[X0:=i_linkPos;  //监视器旋转

A:=222; B:=177; C:=291.7852; D:=286.0173; E:=170.5; F:=131.5; G:=366; H:=-30; I:=280;
X4:=ATAN(H/I); X5:=ATAN(F/G);
X8:=SQRT(F*F+G*G);
X12:=sqrt(H*H+I*I);
X9:=sqrt(E*E+X12*X12-2*E*X12*cos(X0));
X6:=acos((B*B+X8*X8-X9*X9)/(2*B*X8));
X10:=acos((B*B+X9*X9-X8*X8)/(2*B*X9));
X11:=acos((X9*X9+X12*X12-E*E)/(2*X9*X12));
X7:=X10+X11;
X2:=X5-X6;
X3:=pi-X7+X2;
X1:=X3-X4;

monitorAngLink2Image:=X1;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="monitorAngLink2Motor" Id="{be375282-cfa2-4973-91da-b3215777ab52}">
      <Declaration><![CDATA[// TODO
METHOD PROTECTED monitorAngLink2Motor : LREAL
VAR_INPUT
	i_linkPos:LREAL;
END_VAR
VAR
	A,B,C,D,E,F,G,H,I,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,Z0:LREAL;	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[X0:=i_linkPos;  //监视器旋转

A:=222; B:=177; C:=291.7852; D:=286.0173; E:=170.5; F:=131.5; G:=366; H:=-30; I:=280;
X4:=ATAN(H/I); X5:=ATAN(F/G);
X8:=SQRT(F*F+G*G);
X12:=sqrt(H*H+I*I);
X9:=sqrt(E*E+X12*X12-2*E*X12*cos(X0));
X6:=acos((B*B+X8*X8-X9*X9)/(2*B*X8));
X10:=acos((B*B+X9*X9-X8*X8)/(2*B*X9));
X11:=acos((X9*X9+X12*X12-E*E)/(2*X9*X12));
X7:=X10+X11;
X2:=X5-X6;
X3:=pi-X7+X2;
X1:=X3-X4;

monitorAngLink2Motor:=X2;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="monitorAngMotor2Link" Id="{5a608b24-1792-4091-9318-b2f1f860af4d}">
      <Declaration><![CDATA[//TODO
METHOD PROTECTED monitorAngMotor2Link : LREAL
VAR_INPUT
	i_motorPos:LREAL;
END_VAR
VAR
	A,B,C,D,E,F,G,H,I,X0,X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,Z0:LREAL;	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[X2:=i_motorPos;

A:=222; B:=177; C:=291.7852; D:=286.0173; E:=170.5; F:=131.5; G:=366; H:=-30; I:=280;
X5:=atan(F/G);
X6:=X5-X2;
X8:=sqrt(F*F+G*G);
X9:=sqrt(B*B+X8*X8-2*B*X8*cos(X6));
X12:=SQRT(H*H+I*I);
X0:=ACOS((E*E+X12*X12-X9*X9)/(2*E*X12));

monitorAngMotor2Link:=X0;]]></ST>
      </Implementation>
    </Method>
    <Method Name="reachUITargetCheck" Id="{58f1d629-33ee-4e90-90f3-a5c453c13e46}">
      <Declaration><![CDATA[METHOD reachUITargetCheck : bool
VAR
	i :INT;
	err:Vec4d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[vecSub(m_UIData.m_cmdJntPos,m_curJntPos, err);

// joint error check
FOR i:=1 TO 4 DO 
	m_cmdArrival[i] :=  ABS(err[i]) < m_jntSoftwareLimit[i]/2;
END_FOR
	]]></ST>
      </Implementation>
    </Method>
    <Method Name="run" Id="{5adedbe6-c484-4199-b427-bc8af7c6d1b0}">
      <Declaration><![CDATA[METHOD PUBLIC run : BOOL
VAR_IN_OUT CONSTANT
	i_cartUIData : ST_CartUIData;
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// update IO signals
updateIO(i_cartUIData);

// update cart status
updateStatus();

// update controller and command
updateCmds();

//cycle test
cartTestCycle();

//joint test
cartTestJnt();

//current test
cartTestJntCurrent();

// send command to joint driver
FOR i:=1 TO 4 DO
	// joint enable
	IF (m_startMotion=FALSE) AND (g_motionTest.m_enterJntTestCar=FALSE) AND (g_motionTest.m_carJntCurTest=FALSE) THEN		
		IF m_jntEnableFlag[i] AND NOT(SafetyCheck.m_safetyCheckData.m_cartErrFlag[i]) AND MasterArmControl.m_masterStatus.m_armState[1] <> MasterArmState_MasterSlave 
									AND MasterArmControl.m_masterStatus.m_armState[2] <> MasterArmState_MasterSlave THEN
			m_cartJoints[i].enable();
		ELSE
			m_cartJoints[i].disable();
		END_IF
	END_IF
	
	//car joint cycle test-----add code for test
	IF (m_startMotion=TRUE) OR (g_motionTest.m_enterJntTestCar=TRUE) OR (g_motionTest.m_carJntCurTest=TRUE) THEN
		m_cartJoints[i].enable();
	END_IF
	
	// set command position
	IF (g_motionTest.m_carJntCurTest=TRUE) THEN
		m_cartJoints[i].updateCmds(DriverOPMode_Trq,m_cmdJntPos[i],m_cmdJntTrq[i]);
	ELSE
		m_cartJoints[i].updateCmds(DriverOPMode_Pos,m_cmdJntPos[i],m_cmdJntTrq[i]);
	END_IF	
END_FOR

//information update
//infoUpdate();
]]></ST>
      </Implementation>
    </Method>
    <Property Name="status" Id="{cd2a750f-147a-42a5-85cd-a7d5a815c963}" FolderPath="property\">
      <Declaration><![CDATA[PROPERTY status : ST_CartStatus]]></Declaration>
      <Get Name="Get" Id="{c1788322-40e1-4e3e-a26b-a8239c1e1e6d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[status := m_cartStatus;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="updateCmds" Id="{a083537e-6f52-4b88-8b83-3c9a5d0db87a}">
      <Declaration><![CDATA[METHOD PROTECTED updateCmds : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (m_jntCmdMotionDir[1] <>0 OR m_jntCmdMotionDir[2]<>0 OR m_jntCmdMotionDir[3] <>0 OR m_jntCmdMotionDir[4] <>0) AND m_carInMotion <> 2 THEN
	m_carInMotion := manualAdjust();
ELSIF (m_UIData.m_ergonomicCrl.m_recovErgonEnable OR m_UIData.m_ergonomicCrl.m_cancelRecovErgonEnable) AND m_carInMotion <> 1 THEN
	m_carInMotion := ergonomicAdjust();
ELSE
	m_carInMotion := 0;
END_IF

reachUITargetCheck();
IF m_cmdArrival[1] AND m_cmdArrival[2] AND m_cmdArrival[3] AND m_cmdArrival[4] THEN
	IF m_UIData.m_ergonomicCrl.m_recovErgonEnable THEN
		m_cartStatus.m_cancelErgonAdjustArrival := FALSE;
		m_cartStatus.m_ergonAdjustArrival := TRUE;
	END_IF
	IF m_UIData.m_ergonomicCrl.m_cancelRecovErgonEnable THEN
		m_cartStatus.m_ergonAdjustArrival := FALSE;
		m_cartStatus.m_cancelErgonAdjustArrival := TRUE;
	END_IF
ELSE
	m_cartStatus.m_ergonAdjustArrival := FALSE;
	IF m_UIData.m_ergonomicCrl.m_recovErgonEnable THEN
		m_cartStatus.m_cancelErgonAdjustArrival := FALSE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="updateIO" Id="{2eedbee2-a8d4-4513-b19a-4a2795c7d360}">
      <Declaration><![CDATA[METHOD PROTECTED updateIO : BOOL
VAR_INPUT
	i_cartUIData : ST_CartUIData;
END_VAR
VAR
	i:INT;
	idxOffset:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// updata IO signals
m_cartStatus.m_clutchSwitch:= m_clutchIOCheck.check(m_clutchPedalIO);
m_cartStatus.m_endoscopeSwitch := m_endoScopeIOCheck.check(m_endoScopePedalIO);
m_cartStatus.m_surgonReady := m_headInCheck.check(m_surgonHeadInIO);
m_cartStatus.m_armSwitch :=m_armSwitchCheck.check(m_armSwitchIO);
m_UIData := i_cartUIData;

//updata Electrotome control
m_elecKnifeCtrlWord := eleKnifeCtrl(MasterArmControl.m_masterStatus.m_armState , MasterArmControl.m_masterStatus.m_teleSlaveArmIdx , MasterArmControl.m_masterInputDataPool.m_slaveStatus.m_instruStauts );

//updata pedal hover and pedal trigger
m_cartStatus. m_pedalHover[1] := m_electricCutLeftAllow OR m_electricCoagulLeftAllow;
m_cartStatus. m_pedalHover[2] := m_electricCutRightAllow OR m_electricCoagulRightAllow;
IF m_electricCutLeftOn AND m_eleCtrlState = 1 THEN
	m_cartStatus.m_electricKnifePedalTrigger[1] := 1;
ELSIF m_electricCoagulLeftOn AND m_eleCtrlState = 1 THEN
	m_cartStatus.m_electricKnifePedalTrigger[1] := 2;
ELSE
	m_cartStatus.m_electricKnifePedalTrigger[1] := 0;
END_IF

IF m_electricCutRightOn AND m_eleCtrlState = 1 THEN
	m_cartStatus.m_electricKnifePedalTrigger[2] := 1;
ELSIF m_electricCoagulRightOn AND m_eleCtrlState = 1 THEN
	m_cartStatus.m_electricKnifePedalTrigger[2] := 2;
ELSE
	m_cartStatus.m_electricKnifePedalTrigger[2] := 0;
END_IF

//update cart joint control switch
FOR i:=1 TO 4 DO 
	idxOffset:= 2*(i-1);
	IF m_cartJointCtrlIOCheck[1+idxOffset].check(m_cartJointCtrlIO[1+idxOffset]) THEN
		m_jntCmdMotionDir[i]:=1;
	ELSIF  m_cartJointCtrlIOCheck[2+idxOffset].check(m_cartJointCtrlIO[2+idxOffset]) THEN
		m_jntCmdMotionDir[i]:=-1;
	ELSE
		m_jntCmdMotionDir[i]:=0;
	END_IF
END_FOR


// if console is already in motion, only check the currently moving joint
IF m_cartStatus.m_consoleInAdjust THEN
	FOR i:=1 TO 4 DO
		IF NOT(m_cartJoints[i].isEnabled()) THEN
			m_jntCmdMotionDir[i] := 0;
		END_IF
	END_FOR
END_IF


// update joint enable flag
FOR i:= 1 TO 4 DO
	IF m_jntCmdMotionDir[i] <> 0 OR m_UIData.m_ergonomicCrl.m_recovErgonEnable OR m_UIData.m_ergonomicCrl.m_cancelRecovErgonEnable THEN
		m_jntEnableFlag[i] := TRUE;
		m_jntEnableCounts[i]:= LIMIT(0, m_jntEnableCounts[i]+1, m_jntEnableCountsThres);
		m_jntDisableCounts[i]:=m_jntEnableCountsThres;
	ELSE
		m_jntEnableCounts[i]:=0;
		m_jntDisableCounts[i]:= LIMIT(0, m_jntDisableCounts[i]-1, m_jntEnableCountsThres);
		m_jntEnableFlag[i] :=m_jntDisableCounts[i]>0; 
	END_IF
END_FOR

// Do not adjust during master-slave control
IF MasterArmControl.m_masterStatus.m_armState[1] = MasterArmState_MasterSlave OR MasterArmControl.m_masterStatus.m_armState[1] = MasterArmState_Endoscope OR
	MasterArmControl.m_masterStatus.m_armState[2] = MasterArmState_MasterSlave OR MasterArmControl.m_masterStatus.m_armState[2] = MasterArmState_Endoscope  THEN
	m_jntCmdMotionDir := g_zeroVec4i;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="updateStatus" Id="{7dc0698e-0910-43df-8937-4fb176791915}">
      <Declaration><![CDATA[METHOD PROTECTED updateStatus : BOOL
VAR_INPUT
END_VAR
VAR
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// update cart joints status
FOR i:=1  TO 4 DO
	m_cartJoints[i].updateStatus();
END_FOR

// get joint data
FOR i:=1 TO 4 DO
	m_curMotorPos[i]:=m_cartJoints[i].motorPos;
	m_curLinkPos[i]:=m_cartJoints[i].linkPos;
	m_curJntPos[i]:=m_cartJoints[i].jntPos;
	m_curJntVel[i]:=m_cartJoints[i].jntVel;
	m_curJntTrq[i]:=m_cartJoints[i].jntTrq;
	m_rawJntCurrent[i]:=m_cartJoints[i].rawCurrent;
	m_filtJntCurrent[i]:=m_cartJoints[i].filtCurrent;
	m_cmdJntCurrent[i]:=m_cartJoints[i].cmdCurrent;
END_FOR 

// transfer monitor angle from link side to motor side
m_curLinkPos[2]:= monitorAngLink2Motor(m_cartJoints[2].linkPos);

// get monitor angle
m_cartStatus.m_monitorAngle:= monitorAngLink2Image(m_cartJoints[2].linkPos);

// check if cart in motion
m_cartStatus.m_consoleInAdjust:=FALSE;
FOR i:=1 TO 4 DO
	IF m_cartJoints[i].isEnabled() THEN
		m_cartStatus.m_consoleInAdjust:=TRUE;
		EXIT;
	END_IF
END_FOR

// check if monitor in motion
m_cartStatus.m_monitorInAdjust:=m_cartJoints[2].isEnabled();

// check if cart in manual adjustment
m_cartStatus.m_consoleInManualAdjust := FALSE;
FOR i:=1 TO 4 DO
	IF m_jntCmdMotionDir[i] <> 0 AND m_cartJoints[i].isEnabled() THEN
		m_cartStatus.m_consoleInManualAdjust := TRUE;
		EXIT;
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_MasterCart">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.cartTestCycle">
      <LineId Id="318" Count="0" />
      <LineId Id="453" Count="0" />
      <LineId Id="455" Count="0" />
      <LineId Id="457" Count="1" />
      <LineId Id="456" Count="0" />
      <LineId Id="459" Count="0" />
      <LineId Id="450" Count="0" />
      <LineId Id="321" Count="27" />
      <LineId Id="470" Count="2" />
      <LineId Id="350" Count="81" />
      <LineId Id="448" Count="0" />
      <LineId Id="447" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="469" Count="0" />
      <LineId Id="445" Count="0" />
      <LineId Id="433" Count="1" />
      <LineId Id="49" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.cartTestJnt">
      <LineId Id="127" Count="60" />
      <LineId Id="197" Count="3" />
      <LineId Id="27" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.cartTestJntCurrent">
      <LineId Id="14" Count="0" />
      <LineId Id="17" Count="3" />
      <LineId Id="22" Count="1" />
      <LineId Id="15" Count="1" />
      <LineId Id="5" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="46" Count="6" />
      <LineId Id="32" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="33" Count="1" />
      <LineId Id="61" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="67" Count="0" />
      <LineId Id="36" Count="2" />
      <LineId Id="43" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="25" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.eleKnifeCtrl">
      <LineId Id="131" Count="31" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.ergonomicAdjust">
      <LineId Id="59" Count="19" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.getStatus">
      <LineId Id="81" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="57" Count="5" />
      <LineId Id="95" Count="1" />
      <LineId Id="56" Count="0" />
      <LineId Id="63" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.infoUpdate">
      <LineId Id="8" Count="0" />
      <LineId Id="28" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="34" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="38" Count="2" />
      <LineId Id="37" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.init">
      <LineId Id="90" Count="23" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.manualAdjust">
      <LineId Id="72" Count="8" />
      <LineId Id="98" Count="2" />
      <LineId Id="84" Count="8" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.monitorAngLink2Image">
      <LineId Id="32" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.monitorAngLink2Motor">
      <LineId Id="32" Count="16" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.monitorAngMotor2Link">
      <LineId Id="27" Count="9" />
      <LineId Id="18" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.reachUITargetCheck">
      <LineId Id="123" Count="0" />
      <LineId Id="125" Count="2" />
      <LineId Id="151" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.run">
      <LineId Id="42" Count="7" />
      <LineId Id="88" Count="2" />
      <LineId Id="110" Count="1" />
      <LineId Id="113" Count="1" />
      <LineId Id="112" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="50" Count="2" />
      <LineId Id="95" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="4" />
      <LineId Id="94" Count="0" />
      <LineId Id="78" Count="2" />
      <LineId Id="76" Count="1" />
      <LineId Id="60" Count="0" />
      <LineId Id="119" Count="1" />
      <LineId Id="122" Count="1" />
      <LineId Id="121" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="132" Count="1" />
      <LineId Id="130" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.status.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.updateCmds">
      <LineId Id="139" Count="10" />
      <LineId Id="167" Count="0" />
      <LineId Id="150" Count="2" />
      <LineId Id="168" Count="0" />
      <LineId Id="153" Count="2" />
      <LineId Id="169" Count="2" />
      <LineId Id="156" Count="0" />
      <LineId Id="119" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.updateIO">
      <LineId Id="154" Count="63" />
      <LineId Id="219" Count="4" />
      <LineId Id="91" Count="0" />
    </LineIds>
    <LineIds Name="FB_MasterCart.updateStatus">
      <LineId Id="131" Count="41" />
      <LineId Id="59" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>