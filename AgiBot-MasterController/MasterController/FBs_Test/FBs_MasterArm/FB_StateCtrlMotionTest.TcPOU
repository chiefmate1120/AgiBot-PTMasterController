<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlMotionTest" Id="{70f647e6-7c05-4a0c-b17e-4c9a147b0142}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_StateCtrlMotionTest EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	//arm id
	m_armId:INT;	
	
	//Precision calculation pre matrix
	m_frontPose:ST_Frame;
	
	//Precision calculation post matrix
	m_endPose:ST_Frame;
	
	//single arm pose
	m_masterArmPose:ST_Frame;
	
	//control mode:  1---Joint space single point motion   2---Continuous joint space motion   3---Single point motion in operating space
	//4---Continuous motion in operating space   5---precision test   6---back to origin position   7---maxmum workspace test
	m_controlMode:INT:=1;
	
	//test step
	m_testStep:INT;
	
	//DH joint position
	m_initDHPos,m_startDHPos,m_endDHPos :Vec7d;
	m_targetDHPos:Vec7d;
	
	//startJntPos,endJntPos :Vec8d;
	m_initJntPos,m_startJntPos,m_endJntPos :Vec7d;
	
	//motion distance
	m_motDist:Vec7d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec7d;
	
	//time
	m_time:LREAL;
	
	//joint motion incresement
	m_jntInc:Vec7d;
	
	//moiton parameters
	m_jntMotionDir:Vec7i:=[0,0,0,0,0,0,0];
	m_jntVel:Vec7d:=[0.1,0.1,0.01,0.2,0.2,0.2,0.2];
	m_defaultJntVel:Vec7d:=[0.1,0.1,0.1,0.1,0.1,0.1,0.1];
	
	//motion start
	m_startMotion:BOOL;
	m_startMotionLast:BOOL;
	
	//target spatial position
	m_targetSpatialPos:ST_Frame;
	
	//spatial motion parameters
	m_spatialMotionDir,m_spatialMotionDirInit:Vec6i;
	m_spatialVel:Vec6d;
	m_spatialMotionDirSum:INT;
	m_defaultSpatialVel:Vec6d:=[0.01,0.01,0.01,0.1,0.1,0.1];
	
	//spatial position incresement
	m_spatialPosInc:Vec6d;
	
	//initial spatial position
	m_initSpatialPos:ST_Frame;
	
	//target position variables
	m_posInc:Vec3d;
	m_axis:Vec3d;
	m_angle:LREAL;
	
	//accuracy test variables
	m_pointNum:INT;
	m_pointSum:INT;
	m_motionCycleNum:INT;
	
	//Precision testing target position
	m_targetPosArr:ARRAY[1..GVL_Const.g_testPointNum] OF ST_Frame;
	m_targetPosVecArr:ARRAY[1..GVL_Const.g_testPointNum,1..7] OF LREAL;
	
	//Maximum workspace testing target position
	m_workspacePosArr:ARRAY[1..GVL_Const.g_testPointNum] OF ST_Frame;
	m_workspacePosVecArr:ARRAY[1..GVL_Const.g_testPointNum,1..7] OF LREAL;
	
	//Has the inverse kinematics been successfully solved
	m_IKSucceed:BOOL;	
	
	//original joint position
	m_originJntPos:Vec7d;
	
	//inverse kinematic idx
	m_IK:INT;
	
	//motion status
	m_motionFinished:BOOL;
	
	//joint control error and current joint position
	m_actualJntPos,m_JntErr:Vec7d;		
	
	//basic function
	m_basicFun:FB_BasicFun;
	
	//unit function
	m_unitFun:FB_UnitTransform;
	
	//motor parameters
	m_motorReduction :LREAL;
	m_trqConst :LREAL;
	m_motorDir :INT;
	m_trq2CurrentRatio:LREAL;
	m_current2TrqRatio:LREAL;
	m_armCurrent2TrqRatio:Vec7d;
	m_jntGravity :Vec7d:=g_zeroVec7d;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="accuracyTest" Id="{afebe618-51ed-4fba-83b4-0fb74d6b8114}">
      <Declaration><![CDATA[METHOD accuracyTest : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //init
		m_pointNum:=1;
		m_pointSum:=8;
		m_motionCycleNum:=1;
		m_testStep:=10;
		
		
	10: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		m_basicFun.activeJnt2DH(i_activeJntPos:= m_endJntPos, o_DHJntPos=> m_endDHPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=100;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=100;
		ELSE
			m_time:=0; m_testStep:=20;
		END_IF		
		
		
	20: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_actualJntPos:=i_masterArm.curJntPos;
		vecSub(m_cmdJntPos, m_actualJntPos, m_JntErr);
		IF (m_time>m_Planner.duration) AND (norm(m_JntErr)<g_jntCtrlAngTolHigh)THEN
			m_testStep:=15;
		END_IF
				
		
	15: //Waiting for confirmation and measurement
		IF (g_motionTest.m_nextStep[m_armId]=TRUE) THEN
			g_motionTest.m_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
	
		//exit
		IF (g_motionTest.m_uiArmMode[m_armId,5]=FALSE) THEN
			m_testStep:=100;
		END_IF
		
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=100;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
				
				
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_Const.g_testMotCycNum) THEN
				m_testStep:=100;
			ELSE
				m_testStep:=10;
			END_IF
		ELSE
			m_testStep:=10;
		END_IF
		
	
	100: //stop
		m_testStep:=-1;	
		m_motionFinished:=TRUE;
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="armIKSlove" Id="{77e37168-bd57-4505-973d-e5e6112185cf}">
      <Declaration><![CDATA[METHOD armIKSlove : BOOL
VAR_INPUT	
	i_masterArm :FB_MasterArm;
	i_q4:LREAL;
	i_targetFrame:ST_Frame;
END_VAR

VAR_OUTPUT
	o_targetJntPos:Vec7d;
END_VAR

VAR
	i:INT;
	IKSucceed:BOOL;
	targetJntPos:Vec7d;		
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Call inverse kinematics
IKSucceed:=m_basicFun.armIK(q4:= i_q4, solution_ID:= m_IK, i_curCartPose:= i_targetFrame, r_jntPos:= targetJntPos);
IF (IKSucceed=FALSE) THEN
	armIKSlove:=FALSE;
	RETURN;
END_IF


//Constrained solution range and transform to active joint position
FOR i:=1 TO 7 BY 1 DO
	m_basicFun.minimumDistMot(i_current:= GVL_Const.g_jntDHInitPos[m_armId,i], i_target:= targetJntPos[i], o_target=> targetJntPos[i]);
END_FOR
m_basicFun.DH2activeJnt(i_DHJntPos:= targetJntPos, o_activeJntPos=> o_targetJntPos);


//Determine whether the solution result is appropriate
FOR i:=1 TO g_mJntNum BY 1 DO
	IF (o_targetJntPos[i]>GVL_ArmJointParameters.g_maxJntPos[m_armId,i]) OR (o_targetJntPos[i]<GVL_ArmJointParameters.g_minJntPos[m_armId,i]) THEN
		armIKSlove:=FALSE;
		RETURN;
	END_IF
END_FOR
armIKSlove:=TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="back2origin" Id="{65a779a8-38b1-4897-9383-89c538a91bfc}">
      <Declaration><![CDATA[METHOD back2origin : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;		
		m_time:=0;
		m_motionFinished:=TRUE;
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{0fa515f5-8ed2-411f-8a91-980e3960824a}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR
	i:INT;
	tmpFrame:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Basic information update---front pose frame and end pose frame
m_frontPose:=i_shoulderPose;
m_endPose.m_pos:=g_zeroVec3d;  m_endPose.m_rot:=g_eye3d;
m_masterArmPose:=i_masterArm.curCartPose;


//copy to global variables
g_motionTest.m_frontPose[m_armId]:=m_frontPose;
g_motionTest.m_endPose[m_armId]:=m_endPose;
g_motionTest.m_masterArmPose[m_armId]:=m_masterArmPose;
g_motionTest.m_armActJntPos[m_armId]:=m_unitFun.masterArmUnit2User(i_dataSystem:= i_masterArm.curJntPos);
m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> g_motionTest.m_armDHJntPos[m_armId]);
g_motionTest.m_curJntCurrent[m_armId]:=i_masterArm.filtJntCurrent;


//joint enable
m_jntEnableFlag :=g_motionTest.m_jntEnable[i_masterArm.armIdx];


//Initialization of motion parameters
m_startMotion:=g_motionTest.m_startMotion[m_armId];
m_controlMode:=g_motionTest.m_controlMode[m_armId];

IF (m_startMotionLast=FALSE) AND (m_startMotion=TRUE) THEN
	m_motionFinished:=FALSE;
	m_testStep:=0;
END_IF
m_startMotionLast:=m_startMotion;



//Select different programs based on different control modes
IF (m_controlMode=1) THEN
	jntSinglePoint(i_masterArm);	
		
ELSIF (m_controlMode=2) THEN
	jntContinuousPoint(i_masterArm);	
		
ELSIF (m_controlMode=3) THEN
	spaceSinglePoint(i_masterArm);	
		
ELSIF (m_controlMode=4) THEN
	spaceContinuousPoint(i_masterArm);
		
ELSIF (m_controlMode=5) THEN
	accuracyTest(i_masterArm);
		
ELSIF (m_controlMode=6) THEN
	back2origin(i_masterArm);
		
ELSIF (m_controlMode=7) THEN
	maxSpaceTest(i_masterArm);
	
ELSIF (m_controlMode=8) THEN
	jntCurrentMode(i_masterArm);
END_IF




//show the motion step
IF (m_controlMode=5) OR (m_controlMode=7) THEN
	g_motionTest.m_curStep[m_armId]:=m_testStep;
	g_motionTest.m_testPointId[m_armId]:=m_pointNum;
	g_motionTest.m_testCycleId[m_armId]:=m_motionCycleNum;
ELSE
	g_motionTest.m_curStep[m_armId]:=-1;
	g_motionTest.m_testPointId[m_armId]:=0;
	g_motionTest.m_testCycleId[m_armId]:=0;
END_IF


(*
// feedback the motion status
IF (m_controlMode=1) OR (m_controlMode=3) OR (m_controlMode=5) OR (m_controlMode=6) OR (m_controlMode=7) THEN
	IF (m_testStep=-1) THEN
		g_motionTest.m_controlMode[m_armId]:=0;	
	END_IF
	
ELSIF (m_controlMode=2) OR (m_controlMode=4) THEN
	IF (m_testStep=-1) THEN
		g_motionTest.m_controlMode[m_armId]:=0;
	END_IF
END_IF
*)


IF (m_testStep=-1) THEN
	g_motionTest.m_controlMode[m_armId]:=0;	
END_IF



//cover the command joint position
IF (g_motionTest.m_coverCmdPos[m_armId]=TRUE) THEN
	g_motionTest.m_targetJntPos[m_armId]:=m_unitFun.masterArmUnit2User(i_dataSystem:= g_motionTest.m_armDHJntPos[m_armId]);
END_IF



//*******************monitor part which can be delete*********************//
GVL_Monitor.g_stateMachine[m_armId]:=MasterArmControl.m_masterRobot.m_masterArmState[m_armId];
GVL_Monitor.g_jntPos[m_armId]:=i_masterArm.curJntPos;
GVL_Monitor.g_step[m_armId]:=m_testStep;
GVL_Monitor.g_time[m_armId]:=m_time;
GVL_Monitor.g_targetPos[m_armId]:=m_cmdJntPos;
GVL_Monitor.g_pointNum[m_armId]:=m_pointNum;
GVL_Monitor.g_startMot[m_armId]:=m_startMotion;
GVL_Monitor.g_motMode[m_armId]:=m_controlMode;


]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq" Id="{d9ac0190-b9c2-4041-ac92-8a2d83683576}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

//do nothing



]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{9671ba1f-3786-4353-99b0-532f4e991b3d}">
      <Declaration><![CDATA[// override this function in each exact controller
// NOTICE: set joint control mode here, and do some initialization if needed
METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR
VAR
	i,j:INT;
	poseVec:Vec6d;
	originPose:ST_Frame;
	gripperRollFlip:BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

//variable initialization
m_armId:=i_masterArm.armIdx;
m_testStep:=-1;

//joint enable
g_motionTest.m_jntEnable[m_armId]:=g_onesVec7i;

//init IK idx
IF (m_armId=1) THEN
	m_IK:=4;
ELSE
	m_IK:=3;
END_IF


//velocity---acceleration---jerk
vecMultiNum(GVL_ArmJointParameters.g_maxJntVel,0.2,m_maxjntVel);
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);


//original joint position
FOR i:=1 TO g_mJntNum BY 1 DO
	m_originJntPos[i]:=GVL_ArmJointCaliData.g_linkEncCaliJntPos[m_armId,i];
END_FOR


//test point record
IF (m_armId=1) THEN
	m_targetPosVecArr:=GVL_Const.g_armPoseA1;
	m_workspacePosVecArr:=GVL_Const.g_maxSpaceArm1;
ELSE
	m_targetPosVecArr:=GVL_Const.g_armPoseA2;
	m_workspacePosVecArr:=GVL_Const.g_maxSpaceArm2;
END_IF



//*************************Accuracy testing target position*********************//
FOR i:=1 TO GVL_Const.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_targetPosVecArr[i,j];
	END_FOR
	m_basicFun.xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_targetPosArr[i]);
	gripperRollFlip:= i_masterArm.gripperRollFlip;
	m_basicFun.armFK(i_jntPos:= m_originJntPos, i_gripperRollFlip:=gripperRollFlip, r_cartPose:= originPose);
	m_targetPosArr[i].m_rot:=originPose.m_rot;
END_FOR



//*******************Maximum workspace testing target position******************//
FOR i:=1 TO GVL_Const.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_workspacePosVecArr[i,j];
	END_FOR
	m_basicFun.xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_workspacePosArr[i]);
	m_basicFun.armFK(i_jntPos:= m_originJntPos, i_gripperRollFlip:=gripperRollFlip, r_cartPose:= originPose);
	m_workspacePosArr[i].m_rot:=originPose.m_rot;
END_FOR


]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntContinuousPoint" Id="{c90c65c0-8df3-44f1-bc0e-2550eda41a32}">
      <Declaration><![CDATA[METHOD jntContinuousPoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //init
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_initDHPos);
		m_jntInc:=g_zeroVec7d;
		m_jntMotionDir:=g_motionTest.m_jntMotionDir[m_armId];
		m_jntVel:=m_unitFun.masterArmUnit2System(i_dataTest:= g_motionTest.m_jntVel[m_armId]);
		
		//If the joint motion direction is specified and the specified speed is 0, then the default speed is used
		FOR i:=1 TO 7 BY 1 DO
			m_jntVel[i]:=LIMIT(-m_defaultJntVel[i],m_jntVel[i],m_defaultJntVel[i]);
			IF (ABS(m_jntMotionDir[i])>0) AND (m_jntVel[i]<g_smallNum) THEN
				m_jntVel[i]:=m_defaultJntVel[i];
			END_IF
		END_FOR
		m_testStep:=10;
		
	
	10://joint motion incresement calculation
		FOR i:=1 TO g_mJntNum BY 1 DO
			m_jntInc[i]:=m_jntInc[i]+m_jntMotionDir[i]*m_jntVel[i]*g_armCtrlCycleTime;
		END_FOR
		
		//determine DH joint position
		vecAdd(m_initDHPos,m_jntInc,m_endDHPos);
		m_basicFun.DH2activeJnt(i_DHJntPos:= m_endDHPos, o_activeJntPos=> m_endJntPos);
		m_cmdJntPos:=m_endJntPos;
		
		//exit
		IF (g_motionTest.m_uiArmMode[m_armId,2]=FALSE) THEN
			m_testStep:=-1;
		END_IF
		
		
	-1://
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntCurrentMode" Id="{3fc73817-122c-4a9a-acd2-ae45dae80e9c}">
      <Declaration><![CDATA[METHOD jntCurrentMode : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
VAR
	i:INT;
	i_jntIdx:INT;
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
	targetTrq:ARRAY[1..7] OF LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //init
		FOR i_jntIdx:=1 TO 7 BY 1 DO
			m_motorReduction :=GVL_ArmJointParameters.g_motorReduction[i_jntIdx];
			m_trqConst :=GVL_ArmJointParameters.g_motorTrqConst[i_jntIdx];
			m_motorDir :=GVL_ArmJointParameters.g_motorDir[m_armId,i_jntIdx];
			m_trq2CurrentRatio:=m_motorDir * 1000.0/(m_trqConst*m_motorReduction);
			m_current2TrqRatio:=m_motorDir * (m_trqConst*m_motorReduction)/1000.0;
			m_armCurrent2TrqRatio[i_jntIdx]:=m_current2TrqRatio;
		END_FOR
		
		//update the torque
		m_jntGravity:=i_masterArm.jntGravity;
		
		SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);	
		FOR i:=1 TO 7 BY 1 DO
			m_jntOPMode[i]:=DriverOPMode_Trq;
			targetTrq[i]:=g_motionTest.m_targetJntCurrent[m_armId][i]*m_armCurrent2TrqRatio[i];
			m_cmdJntTrq[i]:=targetTrq[i]-m_jntGravity[i];
		END_FOR
		copyCmds(r_masterArmCtrlCmd);
		
		m_time:=0;
		m_testStep:=10;


	10: //update the joint current
		m_jntGravity:=i_masterArm.jntGravity;
		FOR i:=1 TO 7 BY 1 DO
			targetTrq[i]:=g_motionTest.m_targetJntCurrent[m_armId][i]*m_armCurrent2TrqRatio[i];
			m_cmdJntTrq[i]:=targetTrq[i]-m_jntGravity[i]-i_masterArm.jntGravityBias[i];
			//g_motionTest.m_curJntCurrent[m_armId][i]:=i_masterArm.curJntTrq[i]/m_armCurrent2TrqRatio[i];
		END_FOR
		
		//actual joint position copy to command joint position
		m_cmdJntPos:=i_masterArm.curJntPos;
		
		//exit
		IF (g_motionTest.m_uiArmMode[m_armId,8]=FALSE) THEN
			m_testStep:=20;
		END_IF
		
		
	20: //Switch to normal state
		SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);	
		copyCmds(r_masterArmCtrlCmd);
		m_motionFinished:=TRUE;
		m_testStep:=-1;
		
		
	-1: //
END_CASE


]]></ST>
      </Implementation>
    </Method>
    <Method Name="jntSinglePoint" Id="{b52fbfef-81d7-4e11-ba89-b951ebd949dd}">
      <Declaration><![CDATA[METHOD jntSinglePoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	curJntPos:Vec7d;
	tgtJntPos:Vec7d;
	tgtJntPosInc:Vec7d;
	i:INT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);	
		tgtJntPos:=m_unitFun.masterArmUnit2System(i_dataTest:= g_motionTest.m_targetJntPos[m_armId]);
		m_basicFun.activeJnt2DH(i_activeJntPos:= tgtJntPos, o_DHJntPos=> m_endDHPos);		
		
		//velocity initial
		m_maxjntVel:=m_unitFun.masterArmUnit2System(i_dataTest:= g_motionTest.m_targetJntVel[m_armId]);
		FOR i:=1 TO 7 BY 1 DO
			IF ABS(m_maxjntVel[i])<g_smallNum THEN
				m_maxjntVel[i]:=1;
			END_IF
		END_FOR		
		vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
		vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);
		
		//joint test mode
		IF (g_motionTest.m_jntPosIncMode[m_armId]=TRUE) THEN
			curJntPos:=i_masterArm.curJntPos;	
			tgtJntPosInc:=m_unitFun.masterArmUnit2System(i_dataTest:= g_motionTest.m_targetJntPosInc[m_armId]);
			vecAdd(curJntPos,tgtJntPosInc,m_endJntPos);
			m_basicFun.activeJnt2DH(i_activeJntPos:= m_endJntPos, o_DHJntPos=> m_endDHPos);
		END_IF
		
		//motion distance judgement
		vecSub(m_endDHPos,m_startDHPos,m_motDist);
		IF (norm(m_motDist)<g_smallNum) THEN
			m_testStep:=20;
			RETURN;
		END_IF		
		
		m_Planner.init(i_startJntPos:= m_startDHPos, 	i_targetJntPos:= m_endDHPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_targetDHPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_basicFun.DH2activeJnt(i_DHJntPos:= m_targetDHPos, o_activeJntPos=> m_cmdJntPos);		
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="maxSpaceTest" Id="{b743c633-b946-4183-8086-7c964c58d1ae}">
      <Declaration><![CDATA[METHOD maxSpaceTest : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
CASE m_testStep OF
	0: //init
		m_pointNum:=1;
		m_pointSum:=8;
		m_motionCycleNum:=1;
		m_testStep:=10;
		
		
	10: //data initial
		m_targetSpatialPos:=m_workspacePosArr[m_pointNum];
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=20;
		END_IF
		
		
	20: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_actualJntPos:=i_masterArm.curJntPos;
		vecSub(m_cmdJntPos, m_actualJntPos, m_JntErr);
		IF (m_time>m_Planner.duration) AND (norm(m_JntErr)<g_jntCtrlAngTolHigh)THEN
			m_testStep:=15;
		END_IF
		
		
	15: //Waiting for confirmation and measurement
		IF (g_motionTest.m_nextStep[m_armId]=TRUE) THEN
			g_motionTest.m_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
		
		//exit
		IF (g_motionTest.m_uiArmMode[m_armId,7]=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
		
		
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_Const.g_testMotCycNum) THEN
				m_testStep:=60;
			ELSE
				m_testStep:=10;
			END_IF
		ELSE
			m_testStep:=10;
		END_IF
				
		
	60: //stop
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE
]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceContinuousPoint" Id="{6d82d01c-ca27-4e66-8af1-0fba9fec3714}">
      <Declaration><![CDATA[METHOD spaceContinuousPoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR

VAR
	i:INT;
	rotMatrix:Mat3d;
	tmpFrame:ST_Frame;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //init
		m_spatialMotionDir:=g_motionTest.m_spatialMotionDir[m_armId];
		m_spatialVel:=m_unitFun.spacePos2System(i_dataSystem:= g_motionTest.m_spatialVel[m_armId]);
		m_initSpatialPos:=i_masterArm.curCartPose;
		m_spatialPosInc:=g_zeroVec6d;
		
		//Only one direction of movement is allowed at a time
		m_spatialMotionDirSum:=0;
		FOR i:=1 TO 6 BY 1 DO
			m_spatialMotionDirSum:=m_spatialMotionDirSum+m_spatialMotionDir[i]*m_spatialMotionDir[i];
		END_FOR
		IF (m_spatialMotionDirSum)>1.0 THEN
			m_spatialMotionDir:=m_spatialMotionDirInit;
		END_IF
		
		//If the spatial motion direction is specified and the specified speed is 0, then the default speed is used
		FOR i:=1 TO 6 BY 1 DO
			m_spatialVel[i]:=LIMIT(-m_defaultSpatialVel[i],m_spatialVel[i],m_defaultSpatialVel[i]);
			IF (ABS(m_spatialMotionDir[i])>0) AND (m_spatialVel[i]<g_smallNum) THEN
				m_spatialVel[i]:=m_defaultSpatialVel[i];
			END_IF
		END_FOR
		m_testStep:=10;
	
	
	10: //spatial motion incresement calculation		
		FOR i:=1 TO 6 BY 1 DO
			m_spatialPosInc[i]:=m_spatialPosInc[i]+m_spatialMotionDir[i]*m_spatialVel[i]*g_armCtrlCycleTime;
		END_FOR

		//Calculate the target pose matrix
		FOR i:=1 TO 3 BY 1 DO
			m_posInc[i]:=m_spatialPosInc[i];
			m_axis[i]:=m_spatialMotionDir[i+3];
		END_FOR
		m_angle:=norm(m_spatialPosInc);
		tmpFrame.m_pos:=m_posInc;
		tmpFrame.m_rot:=angAxis2Rot(m_angle,m_axis);
		m_targetSpatialPos:=transform(m_initSpatialPos,tmpFrame);

		//Inverse kinematics solution of surgical arm
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			RETURN;
		END_IF
		m_cmdJntPos:=m_endJntPos;

		//exit
		IF (g_motionTest.m_uiArmMode[m_armId,4]=FALSE) THEN
			m_testStep:=-1;
		END_IF
		
		
	-1: //	
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <Method Name="spaceSinglePoint" Id="{6f6e85b5-3e0b-492e-b9bb-00296dfc14b0}">
      <Declaration><![CDATA[METHOD spaceSinglePoint : BOOL
VAR_INPUT
	i_masterArm :FB_MasterArm;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

CASE m_testStep OF
	0: //Trajectory parameter initialization
		m_targetSpatialPos:=g_motionTest.m_targetSpatialPos[m_armId];
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=20;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;
		//motion distance judgement
		vecSub(m_endJntPos,m_startJntPos,m_motDist);
		IF (norm(m_motDist)<g_smallNum) THEN
			m_testStep:=20;
			RETURN;
		END_IF
		
		
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=20;
		ELSE
			m_time:=0; m_testStep:=10;
		END_IF		
		
		
	10: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=20;
		END_IF		
		
		
	20: //end the motion
		m_testStep:=-1;
		m_motionFinished:=TRUE;
END_CASE]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlMotionTest">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.accuracyTest">
      <LineId Id="7" Count="0" />
      <LineId Id="13" Count="1" />
      <LineId Id="124" Count="0" />
      <LineId Id="130" Count="1" />
      <LineId Id="129" Count="0" />
      <LineId Id="127" Count="1" />
      <LineId Id="125" Count="0" />
      <LineId Id="15" Count="1" />
      <LineId Id="61" Count="1" />
      <LineId Id="119" Count="0" />
      <LineId Id="19" Count="4" />
      <LineId Id="25" Count="10" />
      <LineId Id="114" Count="0" />
      <LineId Id="113" Count="0" />
      <LineId Id="36" Count="2" />
      <LineId Id="112" Count="0" />
      <LineId Id="63" Count="1" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="0" />
      <LineId Id="69" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="138" Count="2" />
      <LineId Id="136" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="81" Count="15" />
      <LineId Id="77" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="41" Count="9" />
      <LineId Id="101" Count="1" />
      <LineId Id="51" Count="4" />
      <LineId Id="107" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.armIKSlove">
      <LineId Id="26" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.back2origin">
      <LineId Id="7" Count="4" />
      <LineId Id="14" Count="17" />
      <LineId Id="44" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="32" Count="2" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.calcCmdJntPos">
      <LineId Id="12" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="32" Count="3" />
      <LineId Id="22" Count="3" />
      <LineId Id="13" Count="0" />
      <LineId Id="273" Count="1" />
      <LineId Id="325" Count="0" />
      <LineId Id="275" Count="1" />
      <LineId Id="310" Count="0" />
      <LineId Id="308" Count="1" />
      <LineId Id="36" Count="0" />
      <LineId Id="39" Count="1" />
      <LineId Id="220" Count="1" />
      <LineId Id="41" Count="0" />
      <LineId Id="219" Count="0" />
      <LineId Id="222" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="37" Count="1" />
      <LineId Id="203" Count="0" />
      <LineId Id="44" Count="1" />
      <LineId Id="47" Count="16" />
      <LineId Id="79" Count="2" />
      <LineId Id="291" Count="0" />
      <LineId Id="293" Count="0" />
      <LineId Id="292" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="202" Count="0" />
      <LineId Id="84" Count="1" />
      <LineId Id="88" Count="1" />
      <LineId Id="107" Count="1" />
      <LineId Id="91" Count="1" />
      <LineId Id="109" Count="1" />
      <LineId Id="90" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="187" Count="0" />
      <LineId Id="152" Count="1" />
      <LineId Id="155" Count="0" />
      <LineId Id="158" Count="2" />
      <LineId Id="258" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="253" Count="0" />
      <LineId Id="256" Count="1" />
      <LineId Id="157" Count="0" />
      <LineId Id="137" Count="0" />
      <LineId Id="326" Count="1" />
      <LineId Id="331" Count="1" />
      <LineId Id="328" Count="1" />
      <LineId Id="351" Count="0" />
      <LineId Id="330" Count="0" />
      <LineId Id="347" Count="2" />
      <LineId Id="238" Count="0" />
      <LineId Id="352" Count="0" />
      <LineId Id="239" Count="1" />
      <LineId Id="245" Count="7" />
      <LineId Id="241" Count="1" />
      <LineId Id="244" Count="0" />
      <LineId Id="163" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.calcCmdJntTrq">
      <LineId Id="12" Count="5" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.init">
      <LineId Id="12" Count="4" />
      <LineId Id="25" Count="0" />
      <LineId Id="125" Count="0" />
      <LineId Id="124" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="19" Count="2" />
      <LineId Id="23" Count="1" />
      <LineId Id="22" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="35" Count="0" />
      <LineId Id="39" Count="3" />
      <LineId Id="90" Count="0" />
      <LineId Id="43" Count="3" />
      <LineId Id="36" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="53" Count="6" />
      <LineId Id="51" Count="0" />
      <LineId Id="75" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="60" Count="8" />
      <LineId Id="11" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="74" Count="0" />
      <LineId Id="76" Count="7" />
      <LineId Id="72" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="84" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.jntContinuousPoint">
      <LineId Id="34" Count="3" />
      <LineId Id="57" Count="2" />
      <LineId Id="95" Count="1" />
      <LineId Id="62" Count="5" />
      <LineId Id="41" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="42" Count="0" />
      <LineId Id="47" Count="6" />
      <LineId Id="43" Count="0" />
      <LineId Id="70" Count="0" />
      <LineId Id="84" Count="2" />
      <LineId Id="82" Count="1" />
      <LineId Id="54" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.jntCurrentMode">
      <LineId Id="7" Count="2" />
      <LineId Id="24" Count="21" />
      <LineId Id="17" Count="0" />
      <LineId Id="20" Count="1" />
      <LineId Id="46" Count="4" />
      <LineId Id="74" Count="0" />
      <LineId Id="51" Count="1" />
      <LineId Id="84" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="53" Count="2" />
      <LineId Id="22" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="61" Count="3" />
      <LineId Id="57" Count="3" />
      <LineId Id="18" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.jntSinglePoint">
      <LineId Id="7" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="141" Count="3" />
      <LineId Id="138" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="104" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="71" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="72" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="61" Count="0" />
      <LineId Id="64" Count="0" />
      <LineId Id="124" Count="4" />
      <LineId Id="121" Count="0" />
      <LineId Id="123" Count="0" />
      <LineId Id="24" Count="4" />
      <LineId Id="12" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="53" Count="0" />
      <LineId Id="55" Count="0" />
      <LineId Id="32" Count="5" />
      <LineId Id="16" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="13" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.maxSpaceTest">
      <LineId Id="8" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="157" Count="1" />
      <LineId Id="156" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="159" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="16" Count="1" />
      <LineId Id="57" Count="1" />
      <LineId Id="20" Count="15" />
      <LineId Id="142" Count="3" />
      <LineId Id="38" Count="1" />
      <LineId Id="79" Count="0" />
      <LineId Id="63" Count="3" />
      <LineId Id="62" Count="0" />
      <LineId Id="60" Count="0" />
      <LineId Id="169" Count="2" />
      <LineId Id="167" Count="1" />
      <LineId Id="94" Count="0" />
      <LineId Id="99" Count="15" />
      <LineId Id="95" Count="1" />
      <LineId Id="98" Count="0" />
      <LineId Id="41" Count="9" />
      <LineId Id="125" Count="1" />
      <LineId Id="51" Count="1" />
      <LineId Id="123" Count="0" />
      <LineId Id="54" Count="1" />
      <LineId Id="134" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.spaceContinuousPoint">
      <LineId Id="7" Count="0" />
      <LineId Id="70" Count="2" />
      <LineId Id="119" Count="19" />
      <LineId Id="118" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="79" Count="1" />
      <LineId Id="108" Count="1" />
      <LineId Id="88" Count="0" />
      <LineId Id="90" Count="9" />
      <LineId Id="101" Count="6" />
      <LineId Id="81" Count="0" />
      <LineId Id="149" Count="3" />
      <LineId Id="116" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="115" Count="0" />
      <LineId Id="117" Count="0" />
      <LineId Id="73" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMotionTest.spaceSinglePoint">
      <LineId Id="7" Count="0" />
      <LineId Id="10" Count="4" />
      <LineId Id="49" Count="0" />
      <LineId Id="16" Count="4" />
      <LineId Id="62" Count="4" />
      <LineId Id="59" Count="2" />
      <LineId Id="22" Count="17" />
      <LineId Id="54" Count="0" />
      <LineId Id="40" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>