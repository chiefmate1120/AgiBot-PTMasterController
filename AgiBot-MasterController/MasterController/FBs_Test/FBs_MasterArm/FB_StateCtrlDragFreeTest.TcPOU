<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlDragFreeTest" Id="{d284671c-0bbc-4741-a91c-7f5281637538}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Master Arm Clutch
FUNCTION_BLOCK PUBLIC FB_StateCtrlDragFreeTest EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// orientation tracking parameters
	m_rotTrackKp : LREAL := 200;
	m_maxTrackVel :LREAL := PI;
	
	// redundant control parameters
	m_jnt4AdjustKp : LREAL :=10;
	m_jnt4MaxVel :LREAL :=pi/3 ;
	m_linearVelLb :LREAL := 0.01;
	m_linearVelUb :LREAL :=0.1;	
	
	m_initJntPos :Vec7d;
	
	// joint4 dynamic limit 
	m_jntPosUb, m_jntPosLb:LREAL;
	m_jntLimitBuffer : LREAL :=2*g_deg2Rad;
	
	//basic function
	m_basicFun:FB_BasicFun;
	
	//unit function
	m_unitFun:FB_UnitTransform;	
	
	//unit transform
	m_unitTransform:FB_UnitTransform;
	
	//joint limit position
	m_DHjntPos:Vec7d;
	m_jntPosMin:Vec7d;
	m_jntPosMax:Vec7d;
	m_jntMotRange:Vec7d;
	
	m_jntPosJ3:LREAL;
	m_jntPosMinJ3:LREAL;
	m_jntPosMaxJ3:LREAL;
	m_jntMotRangeJ3:LREAL;	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="calcCmdJntPos" Id="{528afd71-e89a-4dea-b848-6b4ab7fcb812}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
var 
	i,j : INT;
	rotT,rotErr:Mat3d;
	angle : LREAL;
	axis,localAxis :Vec3d;
	oriJaco:Mat34;
	oriJt:Mat43;
	oriJJt:Mat3d;
	oriJJtInv:Mat3d;
	oriJPinv:Mat43;
	cartTrackVel:Vec3d;
	jntTrackVel:Vec4d;
	JpinvJ, nullJ:Mat4d;
	eye4d :Mat4d := g_eye4d;
	redunCtrlVel :Vec4d;
	jnt4TrackVel :LREAL;
	cmdRotInMonitor:Mat3d;
	invRot:Mat3d;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
(*
IF MasterArmControl.m_masterRobot.m_USKnifeRotClutch[i_slaveIdx] THEN
	calcCmdJntPos_USKnife(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
ELSE
	calcCmdJntPos_BasicInstru(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
END_IF
*)

(*
//show the joint angle
i:=i_masterArm.armIdx;
g_frictionTest.m_armActJntPos[i]:=i_masterArm.curJntPos;
m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> g_frictionTest.m_armDHJntPos[i]);
g_frictionTest.m_armDHJntPos[i]:=m_unitFun.masterArmUnit2User(i_dataSystem:= g_frictionTest.m_armDHJntPos[i]);
*)


//show the joint angle
i:=i_masterArm.armIdx;
g_frictionTest.m_armActJntPos[i]:=i_masterArm.curJntPos;
m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> g_frictionTest.m_armDHJntPos[i]);
g_frictionTest.m_armDHJntPos[i]:=m_unitTransform.masterArmUnit2User(i_dataSystem:= g_frictionTest.m_armDHJntPos[i]);


//Calculate the LIMIT value
m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_DHjntPos);
FOR i:=1 TO 7 BY 1 DO
	IF (m_DHjntPos[i]>m_jntPosMax[i]) THEN
		m_jntPosMax[i]:=m_DHjntPos[i];
	ELSIF (m_DHjntPos[i]<m_jntPosMin[i]) THEN
		m_jntPosMin[i]:=m_DHjntPos[i];
	END_IF
END_FOR
vecSub(m_jntPosMax,m_jntPosMin,m_jntMotRange);

i:=i_masterArm.armIdx;
g_frictionTest.m_jntPosMin[i]:=m_unitTransform.masterArmUnit2User(i_dataSystem:= m_jntPosMin);
g_frictionTest.m_jntPosMax[i]:=m_unitTransform.masterArmUnit2User(i_dataSystem:= m_jntPosMax);
g_frictionTest.m_jntMotRange[i]:=m_unitTransform.masterArmUnit2User(i_dataSystem:= m_jntMotRange);
m_cmdJntPos:=i_masterArm.curJntPos;


//Calculate the limit value
m_jntPosJ3:=i_masterArm.curJntPos[3];
IF (m_jntPosJ3>m_jntPosMaxJ3) THEN
	m_jntPosMaxJ3:=m_jntPosJ3;
ELSIF(m_jntPosJ3<m_jntPosMinJ3) THEN
	m_jntPosMinJ3:=m_jntPosJ3;
END_IF
m_jntMotRangeJ3:=m_jntPosMaxJ3-m_jntPosMinJ3;

g_frictionTest.m_jntPosJ3[i]:=m_jntPosJ3*g_rad2Deg;
g_frictionTest.m_jntPosMaxJ3[i]:=m_jntPosMaxJ3*g_rad2Deg;
g_frictionTest.m_jntPosMinJ3[i]:=m_jntPosMinJ3*g_rad2Deg;
g_frictionTest.m_jntMotRangeJ3[i]:=m_jntMotRangeJ3*g_rad2Deg;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_BasicInstru" Id="{a4c8d983-d2bd-4b26-a097-ed00512f34aa}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_BasicInstru : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
var 
	i,j : INT;
	rotT,rotErr:Mat3d;
	angle : LREAL;
	axis,localAxis :Vec3d;
	oriJaco:Mat34;
	oriJt:Mat43;
	oriJJt:Mat3d;
	oriJJtInv:Mat3d;
	oriJPinv:Mat43;
	cartTrackVel:Vec3d;
	jntTrackVel:Vec4d;
	JpinvJ, nullJ:Mat4d;
	eye4d :Mat4d := g_eye4d;
	redunCtrlVel :Vec4d;
	jnt4TrackVel :LREAL;
	cmdRotInMonitor:Mat3d;
	invRot:Mat3d;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// use matched slave arm orientation as target, and transform from view coordinate to arm coordinate 
//IF i_slaveStatus.m_armState[i_slaveIdx] = SlaveArmState_InstruReady THEN
//	cmdRotInMonitor := i_slaveStatus.m_curArmPose[i_slaveIdx].m_rot;
//	matTranspose(i_shoulderPose.m_rot, invRot);
//	matMultiply(invRot, cmdRotInMonitor, m_cmdCartPose.m_rot);
//	m_cmdCartPose.m_pos:= i_masterArm.curCartPose.m_pos;
//END_IF


// first three joints is passive control
FOR i:=1 TO 3 DO 
	m_cmdJntPos[i]:=i_masterArm.curJntPos[i];
	m_cmdJntVel[i]:=i_masterArm.curJntVel[i];
END_FOR

// compute cartesian tracking velocity
matTranspose(i_masterArm.simCartPose.m_rot, rotT);
matMultiply(rotT, m_cmdCartPose.m_rot, rotErr);
rot2AngAxis(rotErr, angle=>angle,axis=>localAxis);
matMultiVec(i_masterArm.simCartPose.m_rot, localAxis, axis);
vecMultiNum(axis, LIMIT(-m_maxTrackVel, angle*m_rotTrackKp, m_maxTrackVel), cartTrackVel);

// compute pinv of orientation jacobian
FOR i:=1 TO 3 DO
	FOR j:=1 TO 4 DO
		oriJaco[i,j]:=i_masterArm.simJaco[i+3,j+3];
	END_FOR
END_FOR
matTranspose(oriJaco, oriJt);
matMultiply(oriJaco ,oriJt , oriJJt);
invMat3(oriJJt, oriJJtInv);
matMultiply(oriJt, oriJJtInv, oriJPinv);
matMultiVec(oriJpinv, cartTrackVel, jntTrackVel);

// calculate nullspace
matMultiply(oriJPinv, oriJaco, JpinvJ);
matSub(eye4d , JpinvJ, nullJ);

// redundant velocity
jnt4TrackVel:=calcRedunVel(i_masterArm);
redunCtrlVel[1]:=nullJ[1,1]*jnt4TrackVel;
redunCtrlVel[2]:=nullJ[2,1]*jnt4TrackVel;
redunCtrlVel[3]:=nullJ[3,1]*jnt4TrackVel;
redunCtrlVel[4]:=nullJ[4,1]*jnt4TrackVel;

// update final command joint position and velocity
FOR i :=1 TO 4 DO 
	m_cmdJntVel[i+3]:=jntTrackVel[i]+redunCtrlVel[i];
	m_cmdJntPos[i+3]:=m_cmdJntPos[i+3]+m_cmdJntVel[i+3]*g_armCtrlCycleTime;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_USKnife" Id="{9a9690e5-529b-4c95-a8a5-70c76ea2a448}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_USKnife : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
var 
	i,j : INT;
	rotT,rotErr:Mat3d;
	angle : LREAL;
	axis,localAxis :Vec3d;
	oriJaco:Mat34;
	oriJt:Mat43;
	oriJJt:Mat3d;
	oriJJtInv:Mat3d;
	oriJPinv:Mat43;
	cartTrackVel:Vec3d;
	jntTrackVel:Vec4d;
	JpinvJ, nullJ:Mat4d;
	eye4d :Mat4d := g_eye4d;
	redunCtrlVel :Vec4d;
	jnt4TrackVel :LREAL;
	cmdRotInMonitor:Mat3d;
	invRot:Mat3d;
	
	cmdZAxis, curZAxis :Vec3d;
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// use matched slave arm orientation as target, and transform from view coordinate to arm coordinate 
//IF i_slaveStatus.m_armState[i_slaveIdx] = SlaveArmState_InstruReady THEN
//	cmdRotInMonitor := i_slaveStatus.m_curArmPose[i_slaveIdx].m_rot;
//	matTranspose(i_shoulderPose.m_rot, invRot);
//	matMultiply(invRot, cmdRotInMonitor, m_cmdCartPose.m_rot);
//	m_cmdCartPose.m_pos:= i_masterArm.curCartPose.m_pos;
//END_IF

// first three joints is passive control
FOR i:=1 TO 3 DO 
	m_cmdJntPos[i]:=i_masterArm.curJntPos[i];
	m_cmdJntVel[i]:=i_masterArm.curJntVel[i];
END_FOR

// compute cartesian tracking velocity
FOR i:=1 TO 3 DO
	cmdZAxis[i] :=  m_cmdCartPose.m_rot[i,3];
	curZAxis[i] := i_masterArm.simCartPose.m_rot[i,3];
END_FOR
angle := ACOS(LIMIT(-1,vecDot(cmdZAxis,curZAxis),1));
axis := cross(curZAxis, cmdZAxis);
IF ABS(angle)> g_smallAng AND ABS(angle-pi)> g_smallAng THEN
	normalize(axis);
END_IF
vecMultiNum(axis, LIMIT(-m_maxTrackVel, angle*m_rotTrackKp, m_maxTrackVel), cartTrackVel);

// compute pinv of orientation jacobian
FOR i:=1 TO 3 DO
	FOR j:=1 TO 4 DO
		oriJaco[i,j]:=i_masterArm.simJaco[i+3,j+3];
	END_FOR
END_FOR
matTranspose(oriJaco, oriJt);
matMultiply(oriJaco ,oriJt , oriJJt);
invMat3(oriJJt, oriJJtInv);
matMultiply(oriJt, oriJJtInv, oriJPinv);
matMultiVec(oriJpinv, cartTrackVel, jntTrackVel);

// calculate nullspace
matMultiply(oriJPinv, oriJaco, JpinvJ);
matSub(eye4d , JpinvJ, nullJ);

// redundant velocity
jnt4TrackVel:=calcRedunVel(i_masterArm);
redunCtrlVel[1]:=nullJ[1,1]*jnt4TrackVel;
redunCtrlVel[2]:=nullJ[2,1]*jnt4TrackVel;
redunCtrlVel[3]:=nullJ[3,1]*jnt4TrackVel;
redunCtrlVel[4]:=nullJ[4,1]*jnt4TrackVel;

// update final command joint position and velocity
FOR i :=1 TO 3 DO 
	m_cmdJntVel[i+3]:=jntTrackVel[i]+redunCtrlVel[i];
	m_cmdJntPos[i+3]:=m_cmdJntPos[i+3]+m_cmdJntVel[i+3]*g_armCtrlCycleTime;
END_FOR

// allow user to rotate joint7 if hand clutch is triggered
IF i_masterArm.handClutchSwitch THEN
	m_cmdJntPos[7] := i_masterArm.curJntPos[7];
	m_cmdJntVel[7] := i_masterArm.curJntVel[7];
ELSE
	m_cmdJntPos[7] := m_initJntPos[7];
	m_cmdJntVel[7] := 0;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcRedunVel" Id="{3519b555-871c-4539-8a20-52b318fd07e9}">
      <Declaration><![CDATA[METHOD PROTECTED calcRedunVel : LREAL
VAR_IN_OUT CONSTANT
	i_masterArm :FB_MasterArm;
END_VAR

VAR 
	j6Bias,j5Bias :LREAL;
	velScale :LREAL;
	linearVel :Vec3d;
	curJntPos : Vec7d;
	jnt4LinkPos :LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// compute desired joint4 link position
curJntPos :=  i_masterArm.cmdJntPos;
jnt4LinkPos:=i_masterArm.jnt4MotorToLink(curJntPos[2],curJntPos[3],curJntPos[4]);
IF 1= i_masterArm.armIdx THEN
	j6Bias :=curJntPos[6]+PI/2;
ELSE 
	j6Bias := curJntPos[6]-PI/2;
END_IF

// scale based on joint5 position
j5Bias :=  LIMIT (0, ABS(curJntPos[5] -pi), pi/2);
j6Bias := j6Bias * ABS(COS(j5Bias));

// scale based on linear velocity
linearVel[1]:=i_masterArm.curCartTwist[1];
linearVel[2]:=i_masterArm.curCartTwist[2];
linearVel[3]:=i_masterArm.curCartTwist[3];
velScale :=LIMIT(0, (norm(linearVel)-m_linearVelLb)/(m_linearVelUb-m_linearVelLb),1.0);

calcRedunVel := LIMIT(-m_jnt4MaxVel, -j6Bias * m_jnt4AdjustKp * velScale ,m_jnt4MaxVel);

// joint limit
IF (calcRedunVel > 0 AND jnt4LinkPos+calcRedunVel * g_armCtrlCycleTime > GVL_ArmJointParameters.g_maxJntPos[i_masterArm.armIdx,4])
	 OR ( calcRedunVel <0 AND  jnt4LinkPos +calcRedunVel * g_armCtrlCycleTime< GVL_ArmJointParameters.g_minJntPos[i_masterArm.armIdx,4]) THEN
	 calcRedunVel :=0;
END_IF

// position limit check
m_jntPosUb:=i_masterArm.jnt4LinkToMotor(i_masterArm.curJntPos[2],i_masterArm.curJntPos[3],
						 GVL_ArmJointParameters.g_maxJntPos[i_masterArm.armIdx,4]-m_jntLimitBuffer);
m_jntPosLb:=i_masterArm.jnt4LinkToMotor(i_masterArm.curJntPos[2],i_masterArm.curJntPos[3],
						 GVL_ArmJointParameters.g_minJntPos[i_masterArm.armIdx,4]+m_jntLimitBuffer);
IF m_cmdJntPos[4] >=m_jntPosUb OR m_cmdJntPos[4]<m_jntPosLb THEN
	calcRedunVel:=0;
	m_cmdJntPos[4]:=LIMIT(m_jntPosLb,m_cmdJntPos[4],m_jntPosUb);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{b747d3e5-2485-43c2-a645-6401d85f786e}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

(*
m_jntOPMode[1] := DriverOPMode_Trq;
m_jntOPMode[2] := DriverOPMode_Trq;
m_jntOPMode[3] := DriverOPMode_Trq;
m_jntOPMode[4] := DriverOPMode_PosTrq;
m_jntOPMode[5] := DriverOPMode_PosTrq;
m_jntOPMode[6] := DriverOPMode_PosTrq;
m_jntOPMode[7] := DriverOPMode_PosTrq;

m_initJntPos := i_masterArm.curJntPos;

// update commands to arm
copyCmds(r_masterArmCtrlCmd);
*)

m_jntOPMode:=g_allTrqMode;
copyCmds(r_masterArmCtrlCmd);


m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_DHjntPos);
m_jntPosMin:=m_DHjntPos;
m_jntPosMax:=m_DHjntPos;
vecSub(m_jntPosMax,m_jntPosMin,m_jntMotRange);

m_jntPosJ3:=i_masterArm.curJntPos[3];
m_jntPosMinJ3:=m_jntPosJ3;
m_jntPosMaxJ3:=m_jntPosJ3;
m_jntMotRangeJ3:=m_jntPosMaxJ3-m_jntPosMinJ3;
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlDragFreeTest">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlDragFreeTest.calcCmdJntPos">
      <LineId Id="387" Count="1" />
      <LineId Id="326" Count="0" />
      <LineId Id="355" Count="0" />
      <LineId Id="357" Count="1" />
      <LineId Id="356" Count="0" />
      <LineId Id="389" Count="0" />
      <LineId Id="486" Count="0" />
      <LineId Id="390" Count="4" />
      <LineId Id="425" Count="0" />
      <LineId Id="423" Count="0" />
      <LineId Id="454" Count="1" />
      <LineId Id="460" Count="1" />
      <LineId Id="466" Count="3" />
      <LineId Id="562" Count="0" />
      <LineId Id="470" Count="14" />
      <LineId Id="456" Count="0" />
      <LineId Id="515" Count="0" />
      <LineId Id="563" Count="0" />
      <LineId Id="516" Count="0" />
      <LineId Id="519" Count="0" />
      <LineId Id="523" Count="0" />
      <LineId Id="525" Count="0" />
      <LineId Id="527" Count="1" />
      <LineId Id="526" Count="0" />
      <LineId Id="517" Count="1" />
      <LineId Id="131" Count="0" />
      <LineId Id="530" Count="1" />
      <LineId Id="529" Count="0" />
      <LineId Id="533" Count="0" />
      <LineId Id="532" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlDragFreeTest.calcCmdJntPos_BasicInstru">
      <LineId Id="385" Count="49" />
      <LineId Id="131" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlDragFreeTest.calcCmdJntPos_USKnife">
      <LineId Id="527" Count="61" />
      <LineId Id="622" Count="0" />
      <LineId Id="131" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlDragFreeTest.calcRedunVel">
      <LineId Id="77" Count="1" />
      <LineId Id="113" Count="0" />
      <LineId Id="79" Count="4" />
      <LineId Id="125" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="134" Count="5" />
      <LineId Id="133" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="3" />
      <LineId Id="154" Count="5" />
      <LineId Id="153" Count="0" />
      <LineId Id="160" Count="0" />
      <LineId Id="162" Count="0" />
      <LineId Id="161" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlDragFreeTest.init">
      <LineId Id="13" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="66" Count="5" />
      <LineId Id="97" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="112" Count="0" />
      <LineId Id="126" Count="6" />
      <LineId Id="113" Count="0" />
      <LineId Id="144" Count="2" />
      <LineId Id="111" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="147" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>