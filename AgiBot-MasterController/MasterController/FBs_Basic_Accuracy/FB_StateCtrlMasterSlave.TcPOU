<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlMasterSlave" Id="{5b96f309-da76-444d-a9fb-2d4321895cd7}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Master Arm MasterSlave controller
FUNCTION_BLOCK PUBLIC FB_StateCtrlMasterSlave EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// joint4 controller
	m_redunJntCtrl : FB_RedunJntControl;
	
	// flag if project joint4 torque to nullspace
	m_nullspaceCtrl : BOOL :=FALSE;
	
	// boundary limit force feedback
	m_boundaryForce : FB_boundaryForceFeedback;
	
	// joint6 software limit control
	m_jnt6LimitCtrl :FB_Jnt6SWLimit;
	
	// joint torque for master-slave error
	m_boundaryTrq :Vec7d;
	
	// friction compensation scale
	m_frictionCompScale :LREAL :=1.0;
		
	//*****************Variables related to accuracy testing*******************//
	//test step
	m_testStep:INT;
	
	//target spatial position
	m_targetSpatialPos:ST_Frame;
	
	//Precision testing target position
	m_targetPosArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum] OF ST_Frame;
	m_targetPosVecArr:ARRAY[1..GVL_AccuracyTest.g_testPointNum,1..7] OF LREAL;
	
	//accuracy test variables
	m_pointNum:INT;
	m_pointSum:INT;
	m_motionCycleNum:INT;
	
	//DH joint position
	//m_initDHPos,m_startDHPos,m_endDHPos :Vec7d;
	m_startDHPos:Vec7d;
	
	//startJntPos,endJntPos :Vec8d;
	m_initJntPos,m_startJntPos,m_endJntPos :Vec7d;
	
	//Trajectory planner
	m_Planner: FB_TrajMoveJ;
	
	//Has the inverse kinematics been successfully solved
	m_IKSucceed:BOOL;	
	
	//original joint position
	m_originJntPos:Vec7d;
	
	//inverse kinematic idx
	m_IK:INT;
	
	//time
	m_time:LREAL;
	
	//arm id
	m_armId:INT;	
	
	//motion parameters
	m_maxjntVel,m_maxjntAcc,m_maxjntJerk:Vec7d;
	
	//joint control error and current joint position
	m_actualJntPos,m_JntErr:Vec7d;		
	
	//basic function
	m_basicFun:FB_BasicFun;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="armIKSlove" Id="{8a953a43-0562-478f-8280-983663fd4584}">
      <Declaration><![CDATA[METHOD armIKSlove : BOOL
VAR_INPUT	
	i_masterArm :FB_MasterArm;
	i_q4:LREAL;
	i_targetFrame:ST_Frame;
END_VAR

VAR_OUTPUT
	o_targetJntPos:Vec7d;
END_VAR

VAR
	i:INT;
	IKSucceed:BOOL;
	targetJntPos:Vec7d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//Call inverse kinematics
IKSucceed:=m_basicFun.armIK(q4:= i_q4, solution_ID:= m_IK, i_curCartPose:= i_targetFrame, r_jntPos:= targetJntPos);
IF (IKSucceed=FALSE) THEN
	armIKSlove:=FALSE;
	RETURN;
END_IF


//Constrained solution range and transform to active joint position
FOR i:=1 TO 7 BY 1 DO
	m_basicFun.minimumDistMot(i_current:= GVL_AccuracyTest.g_jntDHInitPos[m_armId,i], i_target:= targetJntPos[i], o_target=> targetJntPos[i]);
END_FOR
m_basicFun.DH2activeJnt(i_DHJntPos:= targetJntPos, o_activeJntPos=> o_targetJntPos);


//Determine whether the solution result is appropriate
FOR i:=1 TO g_mJntNum BY 1 DO
	IF (o_targetJntPos[i]>GVL_ArmJointParameters.g_maxJntPos[m_armId,i]) OR (o_targetJntPos[i]<GVL_ArmJointParameters.g_minJntPos[m_armId,i]) THEN
		armIKSlove:=FALSE;
		RETURN;
	END_IF
END_FOR
armIKSlove:=TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos" Id="{b549ed00-ec1a-412a-94d0-63a741bf9608}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

IF (GVL_AccuracyTestVar.g_MSPrecisionTest[i_masterArm.armIdx]=FALSE) THEN
	IF i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeS OR 
		i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeU THEN
		calcCmdJntPos_USKnife(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	ELSE
		calcCmdJntPos_BasicInstru(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	END_IF
ELSE
	//All joints are in position mode
	calcCmdJntPos_BasicInstru_Test(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_BasicInstru" Id="{239c44da-fbb4-4bf5-8dd0-8022d66af60b}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_BasicInstru : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_cmdJntPos:=i_masterArm.curJntPos;
m_cmdJntVel:=i_masterArm.curJntVel;
m_cmdCartPose:=i_masterArm.curCartPose;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_BasicInstru_Test" Id="{7e13d979-67ea-4ada-b011-d0dc90d8ce97}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_BasicInstru_Test : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE m_testStep OF
	0: //data initial		
		m_targetSpatialPos:=m_targetPosArr[m_pointNum];
		m_basicFun.activeJnt2DH(i_activeJntPos:= i_masterArm.curJntPos, o_DHJntPos=> m_startDHPos);		
		m_IKSucceed:=armIKSlove(i_masterArm:= i_masterArm, i_q4:= m_startDHPos[4], i_targetFrame:= m_targetSpatialPos, o_targetJntPos=> m_endJntPos);
		IF (m_IKSucceed=FALSE) THEN
			m_testStep:=60;
		END_IF
		
		m_startJntPos:=i_masterArm.curJntPos;	
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=5;
		END_IF		
		
		
	5: //pause and confirm
		(*
		IF (m_motionCycleNum=1) AND (m_pointNum=1) THEN
			IF (GVL_AccuracyTestVar.g_startMotion[m_armId]=TRUE) THEN
				m_testStep:=10;
			END_IF
		ELSE
			m_testStep:=10;
		END_IF
		*)
		m_testStep:=10;
		
		
	10: //start the motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		m_actualJntPos:=i_masterArm.curJntPos;
		vecSub(m_cmdJntPos, m_actualJntPos, m_JntErr);
		IF (m_time>m_Planner.duration) AND (norm(m_JntErr)<g_jntCtrlAngTolHigh)THEN
			m_testStep:=15;
		END_IF
		
		
	15: //Waiting for confirmation and measurement
		IF (GVL_AccuracyTestVar.g_nextStep[m_armId]=TRUE) THEN
			GVL_AccuracyTestVar.g_nextStep[m_armId]:=FALSE;
			m_testStep:=30;
		END_IF
		
		
	30: //back to origin point
		m_startJntPos:=i_masterArm.curJntPos;
		m_endJntPos:=m_originJntPos;
		m_Planner.init(i_startJntPos:= m_startJntPos, 	i_targetJntPos:= m_endJntPos, 	i_maxJntVel:= m_maxjntVel, 	i_maxJntAcc:= m_maxjntAcc, 	i_maxJntJerk:= m_maxjntJerk);
		IF (m_Planner.isGene=FALSE) THEN
			m_testStep:=60;
		ELSE
			m_time:=0; m_testStep:=40;
		END_IF
		
		
	40: //start motion
		m_time:=m_time+g_armCtrlCycleTime;
		m_Planner.evaluate(t:= m_time, jntPos=> m_cmdJntPos, jntVel=> m_cmdJntVel, jntAcc=> m_cmdJntAcc);
		IF (m_time>m_Planner.duration) THEN
			m_testStep:=50;
		END_IF
		
		
	50: //Record the motion cycle
		m_pointNum:=m_pointNum+1;
		IF (m_pointNum>m_pointSum) THEN
			m_pointNum:=1;
			m_motionCycleNum:=m_motionCycleNum+1;
			IF (m_motionCycleNum>GVL_AccuracyTest.g_testMotCycNum) THEN
				m_testStep:=60;
			ELSE
				m_testStep:=0;
			END_IF
		ELSE
			m_testStep:=0;
		END_IF
		
		
	60: //stop
		m_testStep:=-1;
END_CASE



GVL_AccuracyTestVar.g_curStep[m_armId]:=m_testStep;
GVL_AccuracyTestVar.g_testPointId[m_armId]:=m_pointNum;
GVL_AccuracyTestVar.g_testCycleId[m_armId]:=m_motionCycleNum;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntPos_USKnife" Id="{e3490571-181c-4e3a-9266-10457d84eb98}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos_USKnife : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR CONSTANT
	// orientation tracking parameters
	m_rotTrackKp : LREAL := 200;
	m_maxTrackVel :LREAL := PI;
	m_trackAngThres :LREAL := 2* g_deg2rad;
END_VAR
VAR 
	cartTrackVel :Vec3d;
	i,j : INT;
	invRot :Mat3d;
	cmdRotInView:Mat3d;
	rotT,rotErr :Mat3d;
	angle:LREAL;
	axis:Vec3d;
	
	oriJaco:Mat34;
	oriJt:Mat43;
	oriJJt:Mat3d;
	oriJJtInv:Mat3d;
	oriJPinv:Mat43;
	jntTrackVel:Vec4d;
	JpinvJ, nullJ:Mat4d;
	eye4d :Mat4d := g_eye4d;
	redunCtrlVel :Vec4d;
	jnt4TrackVel :LREAL;
	cmdZAxis, curZAxis :Vec3d;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_jntOPMode[1] := DriverOPMode_Trq;
m_jntOPMode[2] := DriverOPMode_Trq;
m_jntOPMode[3] := DriverOPMode_Trq;
m_jntOPMode[4] := DriverOPMode_PosTrq;
m_jntOPMode[5] := DriverOPMode_PosTrq;
m_jntOPMode[6] := DriverOPMode_PosTrq;
m_jntOPMode[7] := DriverOPMode_Trq;

// use matched slave arm orientation as target, 
//	and transform from view coordinate to arm coordinate 
cmdRotInView := i_slaveStatus.m_curArmPose[i_slaveIdx].m_rot;
matTranspose(i_shoulderPose.m_rot, invRot);
matMultiply(invRot, cmdRotInView, m_cmdCartPose.m_rot);
m_cmdCartPose.m_pos:= i_masterArm.curCartPose.m_pos;

// first three joints and joint7 is passive control
FOR i:=1 TO 3 DO 
	m_cmdJntPos[i]:=i_masterArm.curJntPos[i];
	m_cmdJntVel[i]:=i_masterArm.curJntVel[i];
END_FOR
m_cmdJntPos[7]:=i_masterArm.curJntPos[7];
m_cmdJntVel[7]:=i_masterArm.curJntVel[7];

// compute cartesian tracking velocity
FOR i:=1 TO 3 DO
	cmdZAxis[i] :=  m_cmdCartPose.m_rot[i,3];
	curZAxis[i] := i_masterArm.simCartPose.m_rot[i,3];
END_FOR
angle := ACOS(LIMIT(-1,vecDot(cmdZAxis,curZAxis),1));
axis := cross(curZAxis, cmdZAxis);
IF ABS(angle)> g_smallAng AND ABS(angle-pi)> g_smallAng THEN
	normalize(axis);
END_IF
vecMultiNum(axis, LIMIT(-m_maxTrackVel, angle*m_rotTrackKp, m_maxTrackVel), cartTrackVel);

// compute pinv of orientation jacobian
FOR i:=1 TO 3 DO
	FOR j:=1 TO 4 DO
		oriJaco[i,j]:=i_masterArm.simJaco[i+3,j+3];
	END_FOR
END_FOR
matTranspose(oriJaco, oriJt);
matMultiply(oriJaco ,oriJt , oriJJt);
invMat3(oriJJt, oriJJtInv);
matMultiply(oriJt, oriJJtInv, oriJPinv);
matMultiVec(oriJpinv, cartTrackVel, jntTrackVel);

// calculate nullspace
matMultiply(oriJPinv, oriJaco, JpinvJ);
matSub(eye4d , JpinvJ, nullJ);

// redundant velocity
jnt4TrackVel:=calcRedunVel(i_masterArm);
redunCtrlVel[1]:=nullJ[1,1]*jnt4TrackVel;
redunCtrlVel[2]:=nullJ[2,1]*jnt4TrackVel;
redunCtrlVel[3]:=nullJ[3,1]*jnt4TrackVel;
redunCtrlVel[4]:=nullJ[4,1]*jnt4TrackVel;

// update final command joint position and velocity
FOR i :=1 TO 3 DO 
	m_cmdJntVel[i+3]:=jntTrackVel[i]+redunCtrlVel[i];
	m_cmdJntPos[i+3]:=m_cmdJntPos[i+3]+m_cmdJntVel[i+3]*g_armCtrlCycleTime;
END_FOR
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq" Id="{590b7c96-65ed-47d5-8eb2-8a13ee8a5533}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[

IF (GVL_AccuracyTestVar.g_MSPrecisionTest[i_masterArm.armIdx]=FALSE) THEN
	IF i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeS OR 
		i_slaveStatus.m_instruStauts[i_slaveIdx].m_type = InstruType_UltrasoundKnifeU THEN
		calcCmdJntTrq_USKnife(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	ELSE
		calcCmdJntTrq_BasicInstru(i_slaveIdx,i_shoulderPose,i_masterArm,i_slaveStatus);
	END_IF
ELSE
	//All joints are in position mode
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq_BasicInstru" Id="{924c67b8-8dc8-4b14-a8ff-535af80c10ba}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq_BasicInstru : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	nullspaceMat :Mat7d;
	ctrlTrq : Vec7d;
	boundaryTrq :Vec7d;
	withinBoundary :BOOL;
	joint6LimitTrq:LREAL;
	i :INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// boundary force feedback
m_boundaryTrq :=m_boundaryForce.run(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
withinBoundary := (norm(m_boundaryTrq)<g_smallNum);

// redundant joint4 controller
ctrlTrq := g_zeroVec7d;
ctrlTrq[4] := m_redunJntCtrl.run(i_masterArm, i_followEnable:=withinBoundary);

// project to nullspace
IF m_nullspaceCtrl THEN
	nullspaceMat:=i_masterArm.dynaNullspace;
	matMultiVec(nullspaceMat,ctrlTrq, m_cmdJntTrq);
	vecSelfMultiNum(m_cmdJntTrq, ctrlTrq[4] / m_cmdJntTrq[4]);
ELSE
	m_cmdJntTrq := ctrlTrq;
END_IF

// add friction compensation
FOR i:=1 TO g_mJntNum DO 
	m_cmdJntTrq[i] := m_cmdJntTrq[i] +m_frictionCompScale * i_masterArm.jntFriction[i] + m_boundaryTrq[i];
END_FOR

// joint6  limit control
joint6LimitTrq := m_jnt6LimitCtrl.run(i_masterArm);
m_cmdJntTrq[6]:= m_cmdJntTrq[6]+ joint6LimitTrq;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq_USKnife" Id="{89963b71-7e72-4bb1-9f43-b099432ea948}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq_USKnife : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR 
	i :INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_cmdJntTrq :=g_zeroVec7d;
// boundary force feedback
m_boundaryTrq :=m_boundaryForce.run(i_slaveIdx, i_shoulderPose, i_masterArm, i_slaveStatus);
m_cmdJntTrq[7] := m_boundaryTrq[7];
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcRedunVel" Id="{2d8bb2ec-2a44-4bc5-9d2d-80c4739e4cf3}">
      <Declaration><![CDATA[METHOD PROTECTED calcRedunVel : LREAL
VAR_IN_OUT CONSTANT
	i_masterArm :FB_MasterArm;
END_VAR

VAR 
	// redundant control parameters
	m_jnt4AdjustKp : LREAL :=10;
	m_jnt4MaxVel :LREAL :=pi/3 ;
	m_linearVelLb :LREAL := 0.02;
	m_linearVelUb :LREAL :=0.1;	
	
	j6Bias,j5Bias :LREAL;
	velScale :LREAL;
	linearVel :Vec3d;
	curJntPos : Vec7d;
	jnt4LinkPos :LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// compute desired joint4 link position
curJntPos :=  i_masterArm.cmdJntPos;
jnt4LinkPos:=i_masterArm.jnt4MotorToLink(curJntPos[2],curJntPos[3],curJntPos[4]);
IF 1= i_masterArm.armIdx THEN
	j6Bias :=curJntPos[6]+PI/2;
ELSE 
	j6Bias := curJntPos[6]-PI/2;
END_IF

// scale based on joint5 position
j5Bias :=  LIMIT (0, ABS(curJntPos[5] -pi), pi/2);
j6Bias := j6Bias * ABS(COS(j5Bias));

// scale based on linear velocity
linearVel[1]:=i_masterArm.curCartTwist[1];
linearVel[2]:=i_masterArm.curCartTwist[2];
linearVel[3]:=i_masterArm.curCartTwist[3];
velScale :=LIMIT(0, (norm(linearVel)-m_linearVelLb)/(m_linearVelUb-m_linearVelLb),1.0);


calcRedunVel := LIMIT(-m_jnt4MaxVel, -j6Bias * m_jnt4AdjustKp * velScale ,m_jnt4MaxVel);

// joint limit
IF (calcRedunVel > 0 AND jnt4LinkPos+calcRedunVel * g_armCtrlCycleTime > GVL_ArmJointParameters.g_maxJntPos[i_masterArm.armIdx,4])
	 OR ( calcRedunVel <0 AND  jnt4LinkPos +calcRedunVel * g_armCtrlCycleTime< GVL_ArmJointParameters.g_minJntPos[i_masterArm.armIdx,4]) THEN
	 calcRedunVel :=0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{1bea1de4-0538-46fc-be44-e671d6da03c3}">
      <Declaration><![CDATA[METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR

VAR
	i:INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

IF (GVL_AccuracyTestVar.g_MSPrecisionTest[i_masterArm.armIdx]=FALSE) THEN
	m_jntOPMode := g_allTrqMode;
ELSE
	//m_jntOPMode := g_allPosMode; //All joints are in position mode
	m_jntOPMode:=g_allPosTrqMode;
END_IF

// init controller
m_redunJntCtrl.init(i_masterArm);
m_jnt6LimitCtrl.init(i_masterArm);

// update commands to arm
copyCmds(r_masterArmCtrlCmd);


//variable initialization
m_armId:=i_masterArm.armIdx;

//init IK idx
IF (m_armId=1) THEN
	m_IK:=4;
ELSE
	m_IK:=3;
END_IF

//motion parameters initial
motionParamInit(i_masterArm);]]></ST>
      </Implementation>
    </Method>
    <Method Name="motionParamInit" Id="{1c62ec81-0165-4205-bce0-f3ebfd921b2f}">
      <Declaration><![CDATA[METHOD motionParamInit : BOOL
VAR_INPUT
	// arm data
	i_masterArm:FB_MasterArm;
END_VAR
VAR
	i,j:INT;
	poseVec:Vec6d;
	originPose:ST_Frame;
	gripperRollFlip:BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_testStep:=0;
m_time:=0;


//velocity---acceleration---jerk
vecMultiNum(GVL_ArmJointParameters.g_maxJntVel,0.2,m_maxjntVel);
vecMultiNum(m_maxjntVel,3,m_maxjntAcc);
vecMultiNum(m_maxjntAcc,3,m_maxjntJerk);


//accuracy test variables
m_pointNum:=1;
m_pointSum:=8;
m_motionCycleNum:=1;


//original joint position
FOR i:=1 TO g_mJntNum BY 1 DO
	m_originJntPos[i]:=GVL_ArmJointCaliData.g_linkEncCaliJntPos[m_armId,i];
END_FOR


//test point record
IF (m_armId=1) THEN
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA1;
ELSE
	m_targetPosVecArr:=GVL_AccuracyTest.g_armPoseA2;
END_IF


//Accuracy testing target position
FOR i:=1 TO GVL_AccuracyTest.g_testPointNum BY 1 DO
	FOR j:=1 TO 6 BY 1 DO
		poseVec[j]:=m_targetPosVecArr[i,j];
	END_FOR
	m_basicFun.xyzrpy2Frame(i_posVec:= poseVec, o_frame=> m_targetPosArr[i]);
	gripperRollFlip:= i_masterArm.gripperRollFlip;
	m_basicFun.armFK(i_jntPos:= m_originJntPos, i_gripperRollFlip:= gripperRollFlip, r_cartPose:= originPose);
	m_targetPosArr[i].m_rot:=originPose.m_rot;
END_FOR

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlMasterSlave">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.armIKSlove">
      <LineId Id="26" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="27" Count="0" />
      <LineId Id="30" Count="0" />
      <LineId Id="28" Count="1" />
      <LineId Id="31" Count="0" />
      <LineId Id="41" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="68" Count="1" />
      <LineId Id="72" Count="0" />
      <LineId Id="67" Count="0" />
      <LineId Id="22" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="34" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos">
      <LineId Id="141" Count="2" />
      <LineId Id="150" Count="4" />
      <LineId Id="144" Count="0" />
      <LineId Id="146" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="148" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="124" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_BasicInstru">
      <LineId Id="14" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="111" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_BasicInstru_Test">
      <LineId Id="366" Count="91" />
      <LineId Id="111" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntPos_USKnife">
      <LineId Id="382" Count="62" />
      <LineId Id="131" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq">
      <LineId Id="269" Count="0" />
      <LineId Id="260" Count="1" />
      <LineId Id="270" Count="4" />
      <LineId Id="263" Count="0" />
      <LineId Id="265" Count="1" />
      <LineId Id="264" Count="0" />
      <LineId Id="262" Count="0" />
      <LineId Id="245" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq_BasicInstru">
      <LineId Id="204" Count="1" />
      <LineId Id="202" Count="1" />
      <LineId Id="32" Count="0" />
      <LineId Id="48" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="46" Count="0" />
      <LineId Id="54" Count="0" />
      <LineId Id="121" Count="0" />
      <LineId Id="50" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="55" Count="2" />
      <LineId Id="35" Count="0" />
      <LineId Id="182" Count="3" />
      <LineId Id="228" Count="1" />
      <LineId Id="227" Count="0" />
      <LineId Id="230" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcCmdJntTrq_USKnife">
      <LineId Id="243" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="244" Count="0" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.calcRedunVel">
      <LineId Id="77" Count="1" />
      <LineId Id="113" Count="0" />
      <LineId Id="79" Count="4" />
      <LineId Id="125" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="85" Count="1" />
      <LineId Id="134" Count="6" />
      <LineId Id="133" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="3" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.init">
      <LineId Id="13" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="156" Count="1" />
      <LineId Id="180" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="128" Count="1" />
      <LineId Id="127" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="91" Count="0" />
      <LineId Id="158" Count="10" />
      <LineId Id="74" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlMasterSlave.motionParamInit">
      <LineId Id="10" Count="1" />
      <LineId Id="122" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="26" Count="3" />
      <LineId Id="107" Count="0" />
      <LineId Id="30" Count="4" />
      <LineId Id="108" Count="0" />
      <LineId Id="67" Count="1" />
      <LineId Id="70" Count="2" />
      <LineId Id="109" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="73" Count="1" />
      <LineId Id="76" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="77" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="36" Count="6" />
      <LineId Id="135" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="45" Count="1" />
      <LineId Id="111" Count="0" />
      <LineId Id="93" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>